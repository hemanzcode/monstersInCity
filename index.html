<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alien: Spaceship Survival</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            font-family: 'Courier New', monospace;
            background: #000;
        }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            font-size: 18px;
            z-index: 100;
            pointer-events: none;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #f00;
            font-size: 72px;
            text-shadow: 0 0 20px #f00;
            display: none;
            z-index: 200;
            text-align: center;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            font-size: 14px;
            text-align: center;
            z-index: 100;
            pointer-events: none;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid #0ff;
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
            box-shadow: 0 0 10px #0ff;
        }
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
            color: #0ff;
            text-shadow: 0 0 20px #0ff;
        }
        #startScreen h1 {
            font-size: 64px;
            margin-bottom: 30px;
        }
        #startBtn {
            font-size: 24px;
            padding: 15px 40px;
            background: transparent;
            border: 2px solid #0ff;
            color: #0ff;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 10px #0ff;
            transition: all 0.3s;
        }
        #startBtn:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 20px #0ff;
        }
        #customizationScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: row;
            justify-content: space-between;
            align-items: center;
            z-index: 250;
            color: #0ff;
            text-shadow: 0 0 20px #0ff;
            padding: 0 50px;
        }
        #customizationScreen h2 {
            font-size: 48px;
            margin-bottom: 20px;
        }
        .customization-left {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-right: 50px;
        }
        .customization-right {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .custom-section {
            margin: 10px 0;
            text-align: center;
        }
        .custom-section label {
            display: block;
            font-size: 20px;
            margin-bottom: 5px;
        }
        .custom-section select, .custom-section button {
            font-size: 18px;
            padding: 5px 10px;
            background: transparent;
            border: 2px solid #0ff;
            color: #0ff;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 5px #0ff;
            transition: all 0.3s;
        }
        .custom-section select:hover, .custom-section button:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 10px #0ff;
        }
        #confirmBtn {
            font-size: 24px;
            padding: 15px 40px;
            margin-top: 20px;
            background: transparent;
            border: 2px solid #0ff;
            color: #0ff;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 10px #0ff;
            transition: all 0.3s;
        }
        #confirmBtn:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 20px #0ff;
        }
        
        /* Controles Mobile */
        #mobileControls {
            display: none;
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 150;
        }
        
        /* Joystick Virtual */
        #joystickContainer {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 150px;
            height: 150px;
            pointer-events: auto;
        }
        
        #joystickBase {
            position: absolute;
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.2);
            border: 3px solid rgba(0, 255, 255, 0.5);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }
        
        #joystickStick {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.6);
            border: 2px solid #0ff;
            box-shadow: 0 0 15px #0ff;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s;
        }
        
        /* Botões de Ação */
        #actionButtons {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: auto;
        }
        
        .action-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.3);
            border: 3px solid #0ff;
            color: #0ff;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            line-height: 64px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            font-family: 'Courier New', monospace;
            user-select: none;
            touch-action: none;
        }
        
        .action-btn:active {
            background: rgba(0, 255, 255, 0.6);
            transform: scale(0.95);
        }
        
        /* Botão de Disparo Grande */
        #shootBtn {
            width: 80px;
            height: 80px;
            line-height: 74px;
            font-size: 16px;
        }
        
        /* Detectar Mobile */
        @media (max-width: 768px), (pointer: coarse) {
            #mobileControls {
                display: block;
            }
            
            #instructions {
                display: none;
            }
            
            #hud {
                font-size: 14px;
            }
        }
        /* Inventory icons and states */
        .weapon-slot { position: relative; min-width: 90px; min-height: 86px; }
        .weapon-slot .icon { width: 40px; height: 40px; margin: 6px auto 8px; position: relative; }
        .weapon-slot .ammo { color: #ffffff; text-align: center; font-size: 14px; }
        .weapon-slot.available { border-color: #00d4ff !important; background: rgba(0, 212, 255, 0.12) !important; }
        .weapon-slot.selected { outline: 2px solid #00d4ff; box-shadow: 0 0 10px #00d4ff; }
        /* Icons */
        .icon-laser::before { content: ''; position: absolute; left: 4px; right: 4px; top: 18px; height: 4px; background: #00ff88; box-shadow: 0 0 8px #00ff88; }
        .icon-grenade::before { content: ''; position: absolute; width: 24px; height: 24px; border-radius: 50%; background: #2ecc71; top: 8px; left: 8px; box-shadow: 0 0 6px #2ecc71; }
        .icon-grenade::after { content: ''; position: absolute; width: 10px; height: 6px; background: #2ecc71; top: 2px; left: 18px; border-radius: 2px; }
        .icon-mine::before { content: ''; position: absolute; width: 26px; height: 26px; border-radius: 50%; background: #ffd93d; top: 7px; left: 7px; box-shadow: 0 0 6px #ffd93d; }
        .icon-mine::after { content: ''; position: absolute; width: 28px; height: 4px; background: #ffd93d; top: 18px; left: 6px; box-shadow: 0 0 6px #ffd93d; transform: rotate(45deg); }
        .icon-flame::before { content: ''; position: absolute; width: 18px; height: 28px; left: 11px; top: 6px; background: #ff4757; border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%; transform: rotate(15deg); box-shadow: 0 0 8px #ff4757; }
        .icon-plasma::before { content: ''; position: absolute; width: 24px; height: 24px; border-radius: 50%; background: #00d2ff; top: 8px; left: 8px; box-shadow: 0 0 8px #00d2ff; }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1>ALIEN: SPACESHIP SURVIVAL</h1>
        <p style="margin-bottom: 20px;">Sobreviva aos Xenomorphs na espaçonave infectada! Encontre suprimentos e escape!</p>
        <button id="startBtn">INICIAR</button>
    </div>
    <div id="customizationScreen">
        <div class="customization-left">
            <h2>Customizar Personagem</h2>
            <div class="custom-section">
                <label for="hairSelect">Cabelo:</label>
                <select id="hairSelect">
                    <option value="none">Nenhum</option>
                    <option value="short">Curto</option>
                    <option value="long">Longo</option>
                    <option value="mohawk">Moicano</option>
                </select>
            </div>
            <div class="custom-section">
                <label for="backpackSelect">Mochila:</label>
                <select id="backpackSelect">
                    <option value="none">Nenhuma</option>
                    <option value="small">Pequena</option>
                    <option value="large">Grande</option>
                </select>
            </div>
            <div class="custom-section">
                <label for="clothesColor">Cor da Roupa:</label>
                <select id="clothesColor">
                    <option value="0x00aaff">Azul (Padrão)</option>
                    <option value="0xff0000">Vermelho</option>
                    <option value="0x00ff00">Verde</option>
                    <option value="0xffff00">Amarelo</option>
                </select>
            </div>
            <div class="custom-section">
                <label for="jacketSelect">Jaqueta:</label>
                <select id="jacketSelect">
                    <option value="none">Nenhuma</option>
                    <option value="leather">Couro</option>
                    <option value="cyber">Cyberpunk</option>
                </select>
            </div>
            <button id="confirmBtn">CONFIRMAR</button>
        </div>
        <div class="customization-right">
            <!-- Personagem será renderizado aqui -->
        </div>
    </div>
    <div id="hud">
        <div>VIDA: <span id="health">100</span></div>
        <div>STAMINA: <span id="stamina">100</span></div>
        <div>SCORE: <span id="score">0</span></div>
        <div>FASE: <span id="level">1</span></div>
        <div>ARMA: <span id="weapon">Nenhuma</span></div>
        <div>TEMPO: <span id="timer">2:00</span></div>
    </div>
    <div id="radioPlayer" style="position: absolute; top: 20px; right: 20px; color: #0ff; text-shadow: 0 0 10px #0ff; font-size: 16px; z-index: 120; display: flex; gap: 8px; align-items: center;">
        <button id="radioToggle" style="background: rgba(0,0,0,0.6); border: 1px solid #00d4ff; color: #00d4ff; padding: 6px 10px; cursor: pointer;">Rádio: Off</button>
        <select id="radioStation" style="background: rgba(0,0,0,0.6); border: 1px solid #00d4ff; color: #00d4ff; padding: 6px 6px; cursor: pointer;">
            <option value="0">Nightride</option>
            <option value="1">Chillsynth</option>
            <option value="2">Electro</option>
        </select>
        <input id="radioVolume" type="range" min="0" max="1" step="0.01" value="0.3" style="width: 100px; accent-color: #00d4ff;">
        <button id="radioMute" style="background: rgba(0,0,0,0.6); border: 1px solid #00d4ff; color: #00d4ff; padding: 6px 8px; cursor: pointer;">Mute</button>
        <span id="radioStatus" style="min-width: 100px; display: inline-block; color: #00d4ff;">Off</span>
    </div>
    <div id="gameOver">
        <div>GAME OVER</div>
        <div style="font-size: 24px; margin-top: 20px;">Pressione R para reiniciar</div>
    </div>
    <div id="instructions">
        WASD: Mover | Espaço: Pular | Clique: Atirar | T: Alternar visão | G: Visão aérea | Q: Inventário | ESC: Sair da primeira pessoa | Escape Pod = Próxima fase
    </div>
    
    <!-- Interface de Inventário -->
    <div id="inventory" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.9); border: 2px solid #00d4ff; padding: 20px; z-index: 200;">
        <h3 style="color: #00d4ff; text-align: center; margin-bottom: 20px;">INVENTÁRIO DE ARMAS</h3>
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; width: 300px;">
            <div id="weapon-0" class="weapon-slot available selected" style="border: 2px solid #00d4ff; padding: 10px; text-align: center; background: rgba(0, 212, 255, 0.1);">
                <div style="color: #00d4ff; font-weight: bold;">Laser Gun</div>
                <div class="icon icon-laser"></div>
                <div class="ammo">∞</div>
            </div>
            <div id="weapon-1" class="weapon-slot" style="border: 2px solid #666; padding: 10px; text-align: center; background: rgba(0, 0, 0, 0.5);">
                <div style="color: #666; font-weight: bold;">Granadas</div>
                <div class="icon icon-grenade"></div>
                <div class="ammo" id="ammo-grenade" style="color: #666;">0/5</div>
            </div>
            <div id="weapon-2" class="weapon-slot" style="border: 2px solid #666; padding: 10px; text-align: center; background: rgba(0, 0, 0, 0.5);">
                <div style="color: #666; font-weight: bold;">Minas</div>
                <div class="icon icon-mine"></div>
                <div class="ammo" id="ammo-mine" style="color: #666;">0/5</div>
            </div>
            <div id="weapon-3" class="weapon-slot" style="border: 2px solid #666; padding: 10px; text-align: center; background: rgba(0, 0, 0, 0.5);">
                <div style="color: #666; font-weight: bold;">Lança-chamas</div>
                <div class="icon icon-flame"></div>
                <div class="ammo" id="ammo-flame" style="color: #666;">0/5</div>
            </div>
            <div id="weapon-4" class="weapon-slot" style="border: 2px solid #666; padding: 10px; text-align: center; background: rgba(0, 0, 0, 0.5);">
                <div style="color: #666; font-weight: bold;">Bazuca Plasma</div>
                <div class="icon icon-plasma"></div>
                <div class="ammo" id="ammo-plasma" style="color: #666;">0/5</div>
            </div>
        </div>
        <div style="text-align: center; margin-top: 15px; color: #00d4ff;">Pressione Q para fechar</div>
    </div>
    <div id="crosshair"></div>
    
    <!-- Controles Mobile -->
    <div id="mobileControls">
        <!-- Joystick Virtual -->
        <div id="joystickContainer">
            <div id="joystickBase"></div>
            <div id="joystickStick"></div>
        </div>
        
        <!-- Botões de Ação -->
        <div id="actionButtons">
            <div class="action-btn" id="jumpBtn">PULAR</div>
            <div class="action-btn" id="shootBtn">ATIRAR</div>
            <div class="action-btn" id="viewBtn">VISÃO</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Variáveis globais
        let scene, camera, renderer, player;
        let enemies = [], buildings = [], vehicles = [], projectiles = [], pickups = [], pedestrians = [], sidewalks = [], roads = [], walkways = [], ramps = [], train;
        let safeZone, portal;
        let health = 100, stamina = 100, score = 0, level = 1, hasWeapon = false;
        let gameOver = false, gameStarted = false;
        let gameTimer = 600; // 10 minutos em segundos
        let lastSpawnTime = 0;
        let keys = {}, velocity = new THREE.Vector3();
        let isOnGround = true, walkCycle = 0;
        let leftArm, rightArm, leftLeg, rightLeg;
        let cameraMode = 'third'; // 'third', 'first', 'god'
        let worldTheme = 0;
        let isInTrain = false;
        let raycaster = new THREE.Raycaster();
        let cameraOffset = 0; // Para ajustar altura da câmera em caso de obstrução
        let fpsWeaponModel = null; // Modelo da arma para primeira pessoa
        let isFiring = false; // manter pressionado
        const fireCooldown = { laser: 0, explosive: 0, flame: 0, mine: 0, plasma: 0 };
        // Coop e placar
        let partner = null;
        let partnerHealth = 100;
        let playerKills = 0;
        let partnerKills = 0;
        let partnerHostile = false;
        let partnerVelocity = new THREE.Vector3();
        // Spawner controlado
        let enemySpawnPoints = [];
        let enemySpawnPoints2F = [];
        let spawnTimer = 0;
        let nextSpawnDelay = 8; // segundos
        let maxConcurrentEnemies = 12;

        // Sistema de armas e inventário
        let currentWeapon = 0; // 0 = Laser Gun (infinita), 1 = Granada, 2 = Mina, 3 = Lança-chamas, 4 = Bazuca de energia
        let weapons = [
            { name: 'Laser Gun', ammo: 100, maxAmmo: 100, damage: 1, type: 'laser' },
            { name: 'Granada', ammo: 0, maxAmmo: 5, damage: 3, type: 'explosive' },
            { name: 'Mina', ammo: 0, maxAmmo: 5, damage: 2, type: 'mine' },
            { name: 'Lança-chamas', ammo: 0, maxAmmo: 5, damage: 2, type: 'flame' },
            { name: 'Bazuca Plasma', ammo: 0, maxAmmo: 5, damage: 4, type: 'plasma' }
        ];
        let showInventory = false;
        let doors = []; // Sistema de portas
        let elevators = []; // Sistema de elevadores
        let boss = null; // Boss do jogo
        // Munição por arma (agora laser tem 100 balas)
        const ammo = {
            grenade: 0,
            mine: 0,
            flame: 0,
            plasma: 0,
            laser: 100
        };
        function updateAmmoUI() {
            const set = (id, val, max) => {
                const el = document.getElementById(id);
                if (!el) return;
                el.textContent = `${val}/${max}`;
                el.style.color = val > 0 ? '#ffffff' : '#666';
                const slot = el.closest('.weapon-slot');
                if (slot) {
                    if (val > 0) {
                        slot.classList.add('available');
                    } else {
                        slot.classList.remove('available');
                    }
                }
            };
            set('ammo-grenade', ammo.grenade, 5);
            set('ammo-mine', ammo.mine, 5);
            set('ammo-flame', ammo.flame, 5);
            set('ammo-plasma', ammo.plasma, 5);

            // Se arma atual ficou sem munição, trocar automaticamente para próxima disponível
            if (!isWeaponAvailable(currentWeapon)) {
                for (let i = 0; i < weapons.length; i++) {
                    const idx = (currentWeapon + 1 + i) % weapons.length;
                    if (isWeaponAvailable(idx)) { selectWeapon(idx); break; }
                }
            }
        }

        function highlightSelectedWeapon() {
            for (let i = 0; i < weapons.length; i++) {
                const el = document.getElementById(`weapon-${i}`);
                if (!el) continue;
                if (i === currentWeapon) {
                    el.classList.add('selected');
                } else {
                    el.classList.remove('selected');
                }
            }
            document.getElementById('weapon').textContent = weapons[currentWeapon].name;
        }

        function isWeaponAvailable(index) {
            const w = weapons[index];
            if (!w) return false;
            if (w.type === 'laser') return true;
            if (w.type === 'explosive') return ammo.grenade > 0;
            if (w.type === 'mine') return ammo.mine > 0;
            if (w.type === 'flame') return ammo.flame > 0;
            if (w.type === 'plasma') return ammo.plasma > 0;
            return false;
        }

        function selectWeapon(index) {
            if (index < 0 || index >= weapons.length) return;
            if (!isWeaponAvailable(index)) return; // só seleciona se tiver munição
            currentWeapon = index;
            highlightSelectedWeapon();
        }

        // Disparo por arma (switch-case)
        function fireWeapon() {
            if (!hasWeapon) return;
            const w = weapons[currentWeapon];
            // Checar munição disponível
            const hasAmmo = (
                (w.type === 'laser' && ammo.laser > 0) ||
                (w.type === 'explosive' && ammo.grenade > 0) ||
                (w.type === 'mine' && ammo.mine > 0) ||
                (w.type === 'flame' && ammo.flame > 0) ||
                (w.type === 'plasma' && ammo.plasma > 0)
            );
            if (!hasAmmo) return;

            // Origem/direção do disparo de acordo com a câmera
            const isFPS = cameraMode === 'first';
            const origin = isFPS ? camera.position.clone() : player.position.clone().add(new THREE.Vector3(0, 1, 0));
            let dir;
            if (isFPS) {
                dir = new THREE.Vector3(0, 0, -1);
                dir.applyEuler(new THREE.Euler(fpsCamera.pitch, fpsCamera.yaw, 0, 'YXZ'));
            } else {
                dir = new THREE.Vector3(Math.sin(player.rotation.y), 0, Math.cos(player.rotation.y));
            }

            switch (w.type) {
                case 'laser': {
                    const proj = new THREE.Mesh(
                        new THREE.SphereGeometry(0.3),
                        new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 1 })
                    );
                    proj.position.copy(origin);
                    projectiles.push({ mesh: proj, velocity: dir.clone().multiplyScalar(0.9), type: 'laser' });
                    scene.add(proj);
                    ammo.laser = Math.max(0, ammo.laser - 1);
                    // Atualizar UI do slot 0 (mostrar 0-100)
                    const slot0 = document.querySelector('#weapon-0 .ammo');
                    if (slot0) slot0.textContent = `${ammo.laser}/${weapons[0].maxAmmo}`;
                    break;
                }
                case 'explosive': { // granada
                    const proj = new THREE.Mesh(
                        new THREE.SphereGeometry(0.25, 12, 12),
                        new THREE.MeshStandardMaterial({ color: 0x2ecc71, emissive: 0x2ecc71, emissiveIntensity: 0.6 })
                    );
                    proj.position.copy(origin);
                    const vel = dir.clone().multiplyScalar(0.5); vel.y += 0.25;
                    projectiles.push({ mesh: proj, velocity: vel, type: 'grenade', life: 300 });
                    scene.add(proj);
                    ammo.grenade--; updateAmmoUI();
                    break;
                }
                case 'mine': {
                    const mine = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.5, 0.5, 0.2, 10),
                        new THREE.MeshStandardMaterial({ color: 0xffd93d, emissive: 0xffd93d, emissiveIntensity: 1 })
                    );
                    mine.position.set(player.position.x, 1.1, player.position.z);
                    scene.add(mine);
                    projectiles.push({ mesh: mine, velocity: new THREE.Vector3(), type: 'mine', armed: true });
                    ammo.mine--; updateAmmoUI();
                    break;
                }
                case 'flame': {
                    // Emissor de partículas laranja (mesma estética da explosão, menor)
                    const group = new THREE.Object3D();
                    const particles = 12;
                    const velocities = [];
                    for (let i = 0; i < particles; i++) {
                        const size = 0.15 + Math.random() * 0.2;
                        const sphere = new THREE.Mesh(
                            new THREE.SphereGeometry(size, 8, 8),
                            new THREE.MeshStandardMaterial({
                                color: 0xff8c42,
                                emissive: 0xff8c42,
                                emissiveIntensity: 1,
                                transparent: true,
                                opacity: 0.9
                            })
                        );
                        sphere.position.set(0, 0, 0);
                        group.add(sphere);
                        const spread = 0.15;
                        const v = new THREE.Vector3(
                            dir.x + (Math.random() - 0.5) * spread,
                            dir.y + (Math.random() - 0.5) * spread * 0.5,
                            dir.z + (Math.random() - 0.5) * spread
                        ).normalize().multiplyScalar(0.6 + Math.random() * 0.4);
                        velocities.push(v);
                    }
                    group.position.copy(origin);
                    projectiles.push({ mesh: group, velocities, type: 'flame', life: 20 });
                    scene.add(group);
                    ammo.flame = Math.max(0, ammo.flame - 1);
                    updateAmmoUI();
                    break;
                }
                case 'plasma': {
                    const proj = new THREE.Mesh(
                        new THREE.SphereGeometry(0.35, 12, 12),
                        new THREE.MeshStandardMaterial({ color: 0x00d2ff, emissive: 0x00d2ff, emissiveIntensity: 1 })
                    );
                    proj.position.copy(origin);
                    projectiles.push({ mesh: proj, velocity: dir.clone().multiplyScalar(1.2), type: 'plasma' });
                    scene.add(proj);
                    ammo.plasma--; updateAmmoUI();
                    break;
                }
                default:
                    break;
            }

            // Animação de recuo na arma FPS
            if (fpsWeaponModel && cameraMode === 'first') {
                const originalZ = fpsWeaponModel.position.z;
                fpsWeaponModel.position.z -= 0.1;
                setTimeout(() => { if (fpsWeaponModel) fpsWeaponModel.position.z = originalZ; }, 50);
            }
        }
        
        // Sistema profissional de câmera primeira pessoa
        let fpsCamera = {
            yaw: 0,           // Rotação horizontal (esquerda/direita)
            pitch: 0,         // Rotação vertical (cima/baixo)
            isLocked: false,  // Se o mouse está bloqueado
            sensitivity: 0.002, // Sensibilidade do mouse
            maxPitch: Math.PI / 2 - 0.1, // Limite máximo de inclinação
            minPitch: -Math.PI / 2 + 0.1  // Limite mínimo de inclinação
        };

        // Variáveis para customização
        let previewScene, previewCamera, previewRenderer, previewPlayer;
        let customHair, customBackpack, customJacket;
        let customClothesColor = 0x00aaff;
        
        // Controles Mobile
        let mobileJoystick = {
            active: false,
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            deltaX: 0,
            deltaY: 0
        };
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // Função para atualizar a orientação da câmera FPS
        function updateFPSCamera(deltaX, deltaY) {
            if (!fpsCamera.isLocked) return;
            
            // Atualizar yaw (rotação horizontal)
            fpsCamera.yaw -= deltaX * fpsCamera.sensitivity;
            
            // Atualizar pitch (rotação vertical) com limitações
            fpsCamera.pitch -= deltaY * fpsCamera.sensitivity;
            fpsCamera.pitch = Math.max(fpsCamera.minPitch, Math.min(fpsCamera.maxPitch, fpsCamera.pitch));
        }

        // Função para calcular direção de movimento baseada na câmera FPS
        function getFPSMovementDirection() {
            const forward = new THREE.Vector3(0, 0, -1); // usar -Z como frente
            const right = new THREE.Vector3(1, 0, 0);
            
            // Aplicar rotação yaw (horizontal)
            forward.applyEuler(new THREE.Euler(0, fpsCamera.yaw, 0));
            right.applyEuler(new THREE.Euler(0, fpsCamera.yaw, 0));
            
            return { forward, right };
        }

        // Função para solicitar bloqueio do ponteiro
        function requestPointerLock() {
            if (cameraMode === 'first' && !fpsCamera.isLocked) {
                document.body.requestPointerLock();
            }
        }

        // Função para liberar bloqueio do ponteiro
        function exitPointerLock() {
            if (fpsCamera.isLocked) {
                document.exitPointerLock();
            }
        }

        // Função para criar o jogador (agora com opções de customização)
        function createPlayer(customOptions = {}) {
            const group = new THREE.Object3D();
            const bodyMat = new THREE.MeshStandardMaterial({ color: customOptions.clothesColor || 0x4a90e2, emissive: 0x1e3a8a, emissiveIntensity: 0.7 }); // Azul mais vibrante

            const body = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.2, 0.4), bodyMat);
            body.position.y = 0.6;
            group.add(body);

            const head = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), new THREE.MeshStandardMaterial({ color: 0xf4a261 }));
            head.position.y = 1.5;
            group.add(head);

            leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.8, 0.25), bodyMat);
            leftArm.position.set(-0.55, 0.6, 0);
            group.add(leftArm);

            rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.8, 0.25), bodyMat);
            rightArm.position.set(0.55, 0.6, 0);
            group.add(rightArm);

            const legMat = new THREE.MeshStandardMaterial({ color: 0x2d3748 });
            leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.9, 0.3), legMat);
            leftLeg.position.set(-0.25, -0.45, 0);
            group.add(leftLeg);

            rightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.9, 0.3), legMat);
            rightLeg.position.set(0.25, -0.45, 0);
            group.add(rightLeg);

            // Adicionar customizações
            if (customOptions.hair) {
                let hairGeom, hairMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
                if (customOptions.hair === 'short') {
                    hairGeom = new THREE.BoxGeometry(0.65, 0.2, 0.65);
                } else if (customOptions.hair === 'long') {
                    hairGeom = new THREE.BoxGeometry(0.65, 0.5, 0.65);
                } else if (customOptions.hair === 'mohawk') {
                    hairGeom = new THREE.BoxGeometry(0.2, 0.4, 0.65);
                }
                customHair = new THREE.Mesh(hairGeom, hairMat);
                customHair.position.set(0, 1.8 + (customOptions.hair === 'long' ? 0.15 : 0), 0);
                group.add(customHair);
            }

            if (customOptions.backpack) {
                let backpackGeom, backpackMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
                if (customOptions.backpack === 'small') {
                    backpackGeom = new THREE.BoxGeometry(0.7, 0.8, 0.5);
                } else if (customOptions.backpack === 'large') {
                    backpackGeom = new THREE.BoxGeometry(0.9, 1.0, 0.6);
                }
                customBackpack = new THREE.Mesh(backpackGeom, backpackMat);
                customBackpack.position.set(0, 0.6, -0.45);
                group.add(customBackpack);
            }

            if (customOptions.jacket) {
                let jacketGeom, jacketMat = new THREE.MeshStandardMaterial({ color: customOptions.jacket === 'leather' ? 0x4a2700 : 0x00ffff });
                jacketGeom = new THREE.BoxGeometry(0.9, 1.3, 0.5);
                customJacket = new THREE.Mesh(jacketGeom, jacketMat);
                customJacket.position.set(0, 0.6, 0);
                group.add(customJacket);
            }

            return group;
        }

        // Função para inicializar a cena de preview de customização
        function initCustomizationPreview() {
            previewScene = new THREE.Scene();
            previewScene.background = new THREE.Color(0x000000);
            previewScene.fog = new THREE.FogExp2(0x000000, 0.1);

            // Calcular tamanho da área direita (metade da tela)
            const rightAreaWidth = window.innerWidth / 2;
            const rightAreaHeight = window.innerHeight;

            previewCamera = new THREE.PerspectiveCamera(75, rightAreaWidth / rightAreaHeight, 0.1, 1000);
            previewRenderer = new THREE.WebGLRenderer({ antialias: true });
            previewRenderer.setSize(rightAreaWidth, rightAreaHeight);
            
            // Adicionar o renderer à área direita
            const rightArea = document.querySelector('.customization-right');
            if (rightArea) {
                rightArea.appendChild(previewRenderer.domElement);
            } else {
                // Fallback: adicionar ao body se a área direita não for encontrada
                document.body.appendChild(previewRenderer.domElement);
                console.log('Área direita não encontrada, usando fallback');
            }

            // Aumentar brilho com mais luzes
            previewScene.add(new THREE.AmbientLight(0xffffff, 1.2)); // Aumentado de 0.5 para 1.2
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.6); // Aumentado de 0.8 para 1.6
            dirLight.position.set(5, 10, 5);
            previewScene.add(dirLight);
            
            // Adicionar luz adicional para mais brilho
            const extraLight = new THREE.DirectionalLight(0xffffff, 0.8);
            extraLight.position.set(-5, 10, -5);
            previewScene.add(extraLight);

            previewCamera.position.set(0, 2, 5);
            previewCamera.lookAt(0, 1.5, 0);

            // Aguardar um frame antes de criar o player para garantir que os elementos HTML estejam prontos
            setTimeout(() => {
                updatePreviewPlayer();
            }, 100);

            function animatePreview() {
                requestAnimationFrame(animatePreview);
                if (previewPlayer) {
                    previewPlayer.rotation.y += 0.01;
                }
                previewRenderer.render(previewScene, previewCamera);
            }
            animatePreview();

            window.addEventListener('resize', () => {
                const newRightAreaWidth = window.innerWidth / 2;
                const newRightAreaHeight = window.innerHeight;
                previewCamera.aspect = newRightAreaWidth / newRightAreaHeight;
                previewCamera.updateProjectionMatrix();
                previewRenderer.setSize(newRightAreaWidth, newRightAreaHeight);
            });
        }

        // Função para atualizar o player de preview com as opções selecionadas
        function updatePreviewPlayer() {
            if (previewPlayer) previewScene.remove(previewPlayer);

            // Verificar se os elementos HTML existem antes de acessá-los
            const hairSelect = document.getElementById('hairSelect');
            const backpackSelect = document.getElementById('backpackSelect');
            const clothesColorSelect = document.getElementById('clothesColor');
            const jacketSelect = document.getElementById('jacketSelect');

            if (!hairSelect || !backpackSelect || !clothesColorSelect || !jacketSelect) {
                console.log('Elementos HTML ainda não estão prontos, aguardando...');
                return;
            }

            const hair = hairSelect.value;
            const backpack = backpackSelect.value;
            const clothesColor = parseInt(clothesColorSelect.value);
            const jacket = jacketSelect.value;

            previewPlayer = createPlayer({ hair, backpack, clothesColor, jacket });
            previewPlayer.position.set(0, 0, 0);
            previewScene.add(previewPlayer);
        }

        // Função para aplicar customizações ao player do jogo
        function applyCustomizations() {
            const hair = document.getElementById('hairSelect').value;
            const backpack = document.getElementById('backpackSelect').value;
            customClothesColor = parseInt(document.getElementById('clothesColor').value);
            const jacket = document.getElementById('jacketSelect').value;

            player = createPlayer({ hair, backpack, clothesColor: customClothesColor, jacket });
            // Spawn na espaçonave
            player.position.set(0, 2, 0); // Centro da espaçonave
            scene.add(player);
        }

        // Adicionar event listeners para atualizar preview em tempo real
        document.getElementById('hairSelect').addEventListener('change', updatePreviewPlayer);
        document.getElementById('backpackSelect').addEventListener('change', updatePreviewPlayer);
        document.getElementById('clothesColor').addEventListener('change', updatePreviewPlayer);
        document.getElementById('jacketSelect').addEventListener('change', updatePreviewPlayer);

        // Função para criar Xenomorph (Alien)
        function createXenomorph() {
            const group = new THREE.Object3D();
            const bodyMat = new THREE.MeshStandardMaterial({ 
                color: 0x000000, 
                emissive: 0x004400, 
                emissiveIntensity: 0.3,
                roughness: 0.9,
                metalness: 0.1
            });

            // Corpo principal - mais alongado e orgânico
            const body = new THREE.Mesh(new THREE.BoxGeometry(2.5, 2, 4), bodyMat);
            body.position.y = 1;
            group.add(body);

            // Cabeça alongada característica do Alien
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.5, 2.5), bodyMat);
            head.position.set(0, 1.5, 2.8);
            head.rotation.x = -0.1;
            group.add(head);

            // Crânio alongado
            const skull = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.2, 2), bodyMat);
            skull.position.set(0, 2.2, 3.5);
            group.add(skull);

            // Cauda longa e flexível
            const tail = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 4), bodyMat);
            tail.position.set(0, 0.8, -3);
            tail.rotation.x = 0.2;
            group.add(tail);

            // Pernas dianteiras mais longas
            const frontLeg1 = new THREE.Mesh(new THREE.BoxGeometry(0.3, 2, 0.3), bodyMat);
            frontLeg1.position.set(-0.8, 0, 1);
            group.add(frontLeg1);

            const frontLeg2 = new THREE.Mesh(new THREE.BoxGeometry(0.3, 2, 0.3), bodyMat);
            frontLeg2.position.set(0.8, 0, 1);
            group.add(frontLeg2);

            // Pernas traseiras
            const backLeg1 = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.8, 0.3), bodyMat);
            backLeg1.position.set(-0.8, 0, -1.5);
            group.add(backLeg1);

            const backLeg2 = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.8, 0.3), bodyMat);
            backLeg2.position.set(0.8, 0, -1.5);
            group.add(backLeg2);

            // Olhos brilhantes (sem íris)
            const eyeMat = new THREE.MeshStandardMaterial({ 
                color: 0x000000, 
                emissive: 0x00ff00, 
                emissiveIntensity: 0.8 
            });
            const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.15), eyeMat);
            eye1.position.set(-0.25, 2.1, 4.2);
            group.add(eye1);

            const eye2 = new THREE.Mesh(new THREE.SphereGeometry(0.15), eyeMat);
            eye2.position.set(0.25, 2.1, 4.2);
            group.add(eye2);

            // Mandíbula interna (dentes)
            const jaw = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.3, 0.8), bodyMat);
            jaw.position.set(0, 1.2, 4.5);
            group.add(jaw);

            return group;
        }

        // Função para criar Facehugger (menor)
        function createFacehugger() {
            const group = new THREE.Object3D();
            const bodyMat = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a1a, 
                emissive: 0x004400, 
                emissiveIntensity: 0.2 
            });

            // Corpo pequeno e achatado
            const body = new THREE.Mesh(new THREE.BoxGeometry(1, 0.3, 1), bodyMat);
            body.position.y = 0.15;
            group.add(body);

            // Pernas longas e finas
            for (let i = 0; i < 8; i++) {
                const leg = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.8, 0.1), bodyMat);
                const angle = (i / 8) * Math.PI * 2;
                leg.position.set(
                    Math.cos(angle) * 0.6,
                    0.4,
                    Math.sin(angle) * 0.6
                );
                group.add(leg);
            }

            // Cauda longa
            const tail = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 1.5), bodyMat);
            tail.position.set(0, 0.15, -0.8);
            group.add(tail);

            return group;
        }

        // Função para criar Boss (Alien Queen)
        function createAlienBoss() {
            const group = new THREE.Object3D();
            const bodyMat = new THREE.MeshStandardMaterial({ 
                color: 0x000000, 
                emissive: 0x004400, 
                emissiveIntensity: 0.4,
                roughness: 0.9,
                metalness: 0.1
            });

            // Corpo principal - muito maior que Xenomorph normal
            const body = new THREE.Mesh(new THREE.BoxGeometry(4, 3, 6), bodyMat);
            body.position.y = 1.5;
            group.add(body);

            // Cabeça massiva
            const head = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2.5, 3.5), bodyMat);
            head.position.set(0, 2.5, 4);
            head.rotation.x = -0.1;
            group.add(head);

            // Crânio alongado ainda maior
            const skull = new THREE.Mesh(new THREE.BoxGeometry(1.2, 2, 2.5), bodyMat);
            skull.position.set(0, 3.5, 5.5);
            group.add(skull);

            // Cauda gigante
            const tail = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 6), bodyMat);
            tail.position.set(0, 1.5, -4);
            tail.rotation.x = 0.3;
            group.add(tail);

            // Pernas dianteiras enormes
            const frontLeg1 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 3.5, 0.5), bodyMat);
            frontLeg1.position.set(-1.5, 0, 2);
            group.add(frontLeg1);

            const frontLeg2 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 3.5, 0.5), bodyMat);
            frontLeg2.position.set(1.5, 0, 2);
            group.add(frontLeg2);

            // Pernas traseiras
            const backLeg1 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 3, 0.5), bodyMat);
            backLeg1.position.set(-1.5, 0, -2);
            group.add(backLeg1);

            const backLeg2 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 3, 0.5), bodyMat);
            backLeg2.position.set(1.5, 0, -2);
            group.add(backLeg2);

            // Olhos vermelhos brilhantes (diferentes dos Xenomorphs normais)
            const eyeMat = new THREE.MeshStandardMaterial({ 
                color: 0x000000, 
                emissive: 0xff0000, 
                emissiveIntensity: 1 
            });
            const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.25), eyeMat);
            eye1.position.set(-0.5, 3.8, 6.5);
            group.add(eye1);

            const eye2 = new THREE.Mesh(new THREE.SphereGeometry(0.25), eyeMat);
            eye2.position.set(0.5, 3.8, 6.5);
            group.add(eye2);

            // Mandíbula interna gigante
            const jaw = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 1.2), bodyMat);
            jaw.position.set(0, 2, 6.8);
            group.add(jaw);

            // Chifres/cristas na cabeça
            for (let i = 0; i < 5; i++) {
                const horn = new THREE.Mesh(
                    new THREE.ConeGeometry(0.2, 1, 6),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x000000, 
                        emissive: 0x004400, 
                        emissiveIntensity: 0.6 
                    })
                );
                horn.position.set(-0.8 + i * 0.4, 4.5, 5);
                group.add(horn);
            }

            return group;
        }

        // Função para criar rótulos (sem mudanças)
        function createLabel(text, color, scale = 5) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;
            ctx.fillStyle = color;
            ctx.font = 'bold 60px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(text, 256, 64);

            const texture = new THREE.CanvasTexture(canvas);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture, transparent: true }));
            sprite.scale.set(scale, scale / 4, 1);
            return sprite;
        }

        // Função para criar portas
        function createDoor(x, y, z, width = 2, height = 4, thickness = 0.2, isOpen = false) {
            const doorGroup = new THREE.Object3D();
            
            // Porta
            const door = new THREE.Mesh(
                new THREE.BoxGeometry(width, height, thickness),
                new THREE.MeshStandardMaterial({ 
                    color: 0x2a2a2a,
                    emissive: 0x004400,
                    emissiveIntensity: 0.1
                })
            );
            door.position.set(x, y + height/2, z);
            doorGroup.add(door);

            // Moldura da porta
            const frame = new THREE.Mesh(
                new THREE.BoxGeometry(width + 0.4, height + 0.4, 0.1),
                new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a1a,
                    emissive: 0x004400,
                    emissiveIntensity: 0.05
                })
            );
            frame.position.set(x, y + height/2, z - 0.05);
            doorGroup.add(frame);

            // Botão para abrir/fechar
            const button = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 16, 16),
                new THREE.MeshStandardMaterial({ 
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.8
                })
            );
            button.position.set(x + width/2 + 0.5, y + height/2, z);
            doorGroup.add(button);

            // Rótulo do botão (instrução)
            const btnLabel = createLabel('CLIQUE PARA ABRIR', '#ffd93d', 6);
            btnLabel.position.set(x + width/2 + 0.5, y + height/2 + 1.5, z + 0.1);
            doorGroup.add(btnLabel);

            doorGroup.door = door;
            doorGroup.button = button;
            doorGroup.buttonLabel = btnLabel;
            doorGroup.isOpen = isOpen;
            doorGroup.originalX = x;
            doorGroup.width = width;

            return doorGroup;
        }

        // Função para criar elevadores funcionais
        function createFunctionalElevator(x, z, isOnFirstFloor = true) {
            const elevatorGroup = new THREE.Object3D();
            
            // Poço do elevador
            const shaft = new THREE.Mesh(
                new THREE.BoxGeometry(4, 20, 4),
                new THREE.MeshStandardMaterial({ 
                    color: 0x2a2a2a,
                    emissive: 0x004400,
                    emissiveIntensity: 0.1
                })
            );
            shaft.position.set(x, 10, z);
            elevatorGroup.add(shaft);

            // Plataforma do elevador (plano roxo com LEDs)
            const platform = new THREE.Mesh(
                new THREE.PlaneGeometry(3.5, 3.5),
                new THREE.MeshStandardMaterial({ 
                    color: 0x6a0dad, // roxo
                    emissive: 0x6a0dad,
                    emissiveIntensity: 0.5,
                    side: THREE.DoubleSide
                })
            );
            platform.position.set(x, isOnFirstFloor ? 2.25 : 12.25, z);
            platform.rotation.x = -Math.PI / 2;
            elevatorGroup.add(platform);

            // Colisor invisível da plataforma (para colisões e detecção)
            const platformCollider = new THREE.Mesh(
                new THREE.BoxGeometry(3.5, 0.5, 3.5),
                new THREE.MeshStandardMaterial({ color: 0x000000, transparent: true, opacity: 0.0 })
            );
            platformCollider.position.set(x, platform.position.y, z);
            platformCollider.userData.elevatorCollider = true;
            elevatorGroup.add(platformCollider);

            // LEDs vermelhos e amarelos na plataforma
            const ledPositions = [
                [-1.4, -1.4], [1.4, -1.4], [1.4, 1.4], [-1.4, 1.4]
            ];
            ledPositions.forEach((p, i) => {
                const color = i % 2 === 0 ? 0xff0000 : 0xffd93d;
                const led = new THREE.Mesh(
                    new THREE.CircleGeometry(0.12, 12),
                    new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 1, side: THREE.DoubleSide })
                );
                led.position.set(x + p[0], platform.position.y + 0.02, z + p[1]);
                led.rotation.x = -Math.PI / 2;
                elevatorGroup.add(led);
            });

            // Botões do elevador
            const buttonUp = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 16, 16),
                new THREE.MeshStandardMaterial({ 
                    color: 0x00ff00,
                    emissive: 0x00ff00,
                    emissiveIntensity: 0.8
                })
            );
            buttonUp.position.set(x + 1.5, 2.5, z);
            elevatorGroup.add(buttonUp);

            const buttonDown = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 16, 16),
                new THREE.MeshStandardMaterial({ 
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.8
                })
            );
            buttonDown.position.set(x - 1.5, 2.5, z);
            elevatorGroup.add(buttonDown);

            elevatorGroup.platform = platform;
            elevatorGroup.platformCollider = platformCollider;
            elevatorGroup.buttonUp = buttonUp;
            elevatorGroup.buttonDown = buttonDown;
            elevatorGroup.isMoving = false;
            elevatorGroup.targetFloor = isOnFirstFloor ? 1 : 2;
            elevatorGroup.currentFloor = isOnFirstFloor ? 1 : 2;
            elevatorGroup.bounds = new THREE.Box3();

            return elevatorGroup;
        }

        // Função para criar mão com arma para primeira pessoa
        function createFPSWeapon() {
            const group = new THREE.Object3D();
            
            // Mão direita
            const handMat = new THREE.MeshStandardMaterial({ color: 0xf4a261 });
            const hand = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.3), handMat);
            hand.position.set(0, 0, 0);
            group.add(hand);
            
            // Braço
            const arm = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.12, 0.4), handMat);
            arm.position.set(0, 0, -0.35);
            group.add(arm);
            
            // Bazuca verde
            const weaponMat = new THREE.MeshStandardMaterial({ 
                color: 0x00ff00, 
                emissive: 0x00ff00, 
                emissiveIntensity: 0.5 
            });
            
            // Corpo da bazuca
            const weaponBody = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.8), weaponMat);
            weaponBody.position.set(0, -0.05, 0.4);
            group.add(weaponBody);
            
            // Gatilho
            const trigger = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.08, 0.05), new THREE.MeshStandardMaterial({ color: 0x333333 }));
            trigger.position.set(0, -0.12, 0.1);
            group.add(trigger);
            
            // Bico da bazuca
            const nozzle = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.18, 0.15), weaponMat);
            nozzle.position.set(0, -0.05, 0.85);
            group.add(nozzle);
            
            // Posicionar no canto inferior direito da tela
            group.position.set(0.3, -0.25, -0.5);
            group.rotation.y = -0.1;
            
            return group;
        }

        // Função para criar pedestre (sem mudanças)
        function createPedestrian(isInteractive = false) {
            const group = new THREE.Object3D();
            const colors = [0xe74c3c, 0x3498db, 0xf39c12, 0x9b59b6, 0x1abc9c, 0xe67e22, 0x2ecc71];
            const color = colors[Math.floor(Math.random() * colors.length)];
            const bodyMat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.3 });

            const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1, 0.3), bodyMat);
            body.position.y = 0.5;
            group.add(body);

            const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), new THREE.MeshStandardMaterial({ color: 0xf4a261 }));
            head.position.y = 1.2;
            group.add(head);

            if (isInteractive) {
                const label = createLabel('Portal está a ' + (Math.random() > 0.5 ? 'norte' : 'sul'), '#ffffff', 6); // Aumentado scale para 6
                label.position.y = 2;
                label.visible = false;
                group.add(label);
            }

            return group;
        }

        // Função para criar cruz vermelha (medicamento) (sem mudanças)
        function createRedCross() {
            const group = new THREE.Object3D();
            const mat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.9 });

            const vertical = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.6, 0.4), mat);
            vertical.position.y = 0.8;
            group.add(vertical);

            const horizontal = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.4, 0.4), mat);
            horizontal.position.y = 0.8;
            group.add(horizontal);

            return group;
        }

        // Função para criar trem (sem mudanças)
        function createTrain() {
            const group = new THREE.Object3D();
            const mat = new THREE.MeshStandardMaterial({ color: 0x333333, emissive: 0x00ffff, emissiveIntensity: 0.5 });

            const body = new THREE.Mesh(new THREE.BoxGeometry(10, 3, 4), mat);
            body.position.y = 1.5;
            group.add(body);

            const wheels = [];
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
            const wheelGeom = new THREE.CylinderGeometry(0.6, 0.6, 0.4, 16);

            for (let i = -1; i <= 1; i += 2) {
                for (let j = -1; j <= 1; j += 2) {
                    const wheel = new THREE.Mesh(wheelGeom, wheelMat);
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(i * 3, 0.3, j * 2);
                    group.add(wheel);
                    wheels.push(wheel);
                }
            }

            return { mesh: group, wheels, speed: 0.3, axis: 'x' };
        }

        // Função para criar explosão (sem mudanças)
        function createExplosion(position) {
            const explosionGroup = new THREE.Object3D();

            for (let i = 0; i < 8; i++) {
                const size = Math.random() * 1.5 + 0.5;
                const sphere = new THREE.Mesh(
                    new THREE.SphereGeometry(size, 8, 8),
                    new THREE.MeshStandardMaterial({
                        color: Math.random() > 0.5 ? 0xff6600 : 0xffff00,
                        emissive: Math.random() > 0.5 ? 0xff6600 : 0xffff00,
                        emissiveIntensity: 2,
                        transparent: true,
                        opacity: 1
                    })
                );
                sphere.position.set(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                );
                explosionGroup.add(sphere);
            }

            explosionGroup.position.copy(position);
            scene.add(explosionGroup);

            let scale = 1;
            const interval = setInterval(() => {
                scale += 0.3;
                explosionGroup.scale.set(scale, scale, scale);
                explosionGroup.children.forEach(child => {
                    child.material.opacity -= 0.1;
                });

                if (scale > 4) {
                    clearInterval(interval);
                    scene.remove(explosionGroup);
                }
            }, 50);
        }

        // Inimigo Vespa (voador)
        function createWasp() {
            const group = new THREE.Object3D();
            const body = new THREE.Mesh(
                new THREE.SphereGeometry(0.7, 12, 12),
                new THREE.MeshStandardMaterial({ color: 0xffc107, emissive: 0xffc107, emissiveIntensity: 1.0 })
            );
            group.add(body);
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.35, 12, 12),
                new THREE.MeshStandardMaterial({ color: 0x222222, emissive: 0xff8c42, emissiveIntensity: 0.8 })
            );
            head.position.set(0, 0.1, 0.8);
            group.add(head);
            // Asas
            const wingMat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.5, emissive: 0x88aaff, emissiveIntensity: 0.6 });
            const wingL = new THREE.Mesh(new THREE.PlaneGeometry(0.25, 1.3), wingMat);
            const wingR = new THREE.Mesh(new THREE.PlaneGeometry(0.25, 1.3), wingMat);
            wingL.rotation.y = Math.PI/2; wingR.rotation.y = Math.PI/2;
            wingL.position.set(-0.6, 0.2, 0.2); wingR.position.set(0.6, 0.2, 0.2);
            group.add(wingL); group.add(wingR);
            group.userData.wings = [wingL, wingR];
            // Luz para destacar a vespa
            const glow = new THREE.PointLight(0xffa500, 0.7, 6);
            glow.position.set(0, 0.2, 0);
            group.add(glow);
            return group;
        }

        // Função para inicializar a cena do jogo (sem mudanças significativas)
        function init() {
            scene = new THREE.Scene();
            updateWorldTheme();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Iluminação melhorada com mais brilho e cores variadas
            scene.add(new THREE.AmbientLight(0x404040, 0.4)); // Luz ambiente mais clara
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8); // Luz principal branca
            mainLight.position.set(50, 100, 50);
            scene.add(mainLight);
            
            // Luz de emergência vermelha
            const emergencyLight = new THREE.DirectionalLight(0xff4444, 0.4);
            emergencyLight.position.set(-50, 80, -50);
            scene.add(emergencyLight);
            
            // Luz ácida verde
            const acidLight = new THREE.PointLight(0x44ff44, 0.8, 30);
            acidLight.position.set(0, 5, 0);
            scene.add(acidLight);
            
            // Luz azul para áreas tecnológicas
            const techLight = new THREE.DirectionalLight(0x4444ff, 0.3);
            techLight.position.set(30, 60, 30);
            scene.add(techLight);

            // Adicionar mais spots de luz para iluminar o ambiente
            const lightPositions = [
                [20, 8, 20], [-20, 8, 20], [20, 8, -20], [-20, 8, -20],
                [0, 8, 30], [0, 8, -30], [30, 8, 0], [-30, 8, 0],
                [15, 15, 15], [-15, 15, 15], [15, 15, -15], [-15, 15, -15]
            ];

            const lightColors = [0x00d4ff, 0xff6b6b, 0x4ecdc4, 0x45b7d1, 0xf9ca24, 0xf0932b, 0xeb4d4b, 0x6c5ce7];

            lightPositions.forEach((pos, i) => {
                const colorIndex = i % lightColors.length;
                const spotLight = new THREE.PointLight(lightColors[colorIndex], 0.6, 25);
                spotLight.position.set(pos[0], pos[1], pos[2]);
                scene.add(spotLight);

                // Adicionar luz de emergência vermelha em alguns pontos
                if (i % 3 === 0) {
                    const emergencySpot = new THREE.PointLight(0xff4444, 0.4, 20);
                    emergencySpot.position.set(pos[0], pos[1] + 2, pos[2]);
                    scene.add(emergencySpot);
                }
            });

            applyCustomizations(); // Aplicar customizações ao player

            generateWorld();

            // Ativar Laser Gun no início
            hasWeapon = true;
            currentWeapon = 0;
            const weaponEl = document.getElementById('weapon');
            if (weaponEl) weaponEl.textContent = 'Laser Gun';
            if (typeof highlightSelectedWeapon === 'function') highlightSelectedWeapon();

            // Criar parceiro aliado próximo ao jogador
            partner = createPlayer({ clothesColor: 0x3498db });
            partner.position.copy(player.position.clone().add(new THREE.Vector3(2, 0, 2)));
            scene.add(partner);

            // Rádio: player de áudio com play/pause, estações e volume
            window.gameRadio = new Audio('');
            window.gameRadio.loop = true;
            window.gameRadio.volume = 0.3; // volume inicial (30%)
            const radioBtn = document.getElementById('radioToggle');
            const radioSel = document.getElementById('radioStation');
            const radioVol = document.getElementById('radioVolume');
            const radioMute = document.getElementById('radioMute');
            const radioStatus = document.getElementById('radioStatus');

            const stations = [
                { name: 'Nightride', url: 'https://stream.nightride.fm/nightride.mp3' },
                { name: 'Chillsynth', url: 'https://stream.nightride.fm/chillsynth.mp3' },
                { name: 'Electro', url: 'https://stream.nightride.fm/electro.mp3' }
            ];

            function setStationByIndex(idx) {
                const s = stations[idx] || stations[0];
                // Se estiver tocando, trocar mantendo play
                const wasPlaying = !window.gameRadio.paused;
                window.gameRadio.src = s.url;
                if (wasPlaying) {
                    window.gameRadio.play().then(() => { radioStatus.textContent = s.name; }).catch(() => { radioStatus.textContent = 'Erro'; });
                } else {
                    radioStatus.textContent = 'Off';
                }
            }

            if (radioBtn) {
                radioBtn.addEventListener('click', () => {
                    if (!window.gameRadio.src) setStationByIndex(0);
                    if (window.gameRadio.paused) {
                        window.gameRadio.play().then(() => {
                            radioBtn.textContent = 'Rádio: On';
                            radioStatus.textContent = stations[radioSel.value|0].name;
                        }).catch(() => {
                            radioStatus.textContent = 'Erro';
                        });
                    } else {
                        window.gameRadio.pause();
                        radioBtn.textContent = 'Rádio: Off';
                        radioStatus.textContent = 'Off';
                    }
                });
            }

            if (radioSel) {
                radioSel.addEventListener('change', () => {
                    setStationByIndex(radioSel.value|0);
                });
            }

            if (radioVol) {
                radioVol.addEventListener('input', () => {
                    window.gameRadio.volume = parseFloat(radioVol.value);
                });
            }

            if (radioMute) {
                radioMute.addEventListener('click', () => {
                    window.gameRadio.muted = !window.gameRadio.muted;
                    radioMute.textContent = window.gameRadio.muted ? 'Unmute' : 'Mute';
                });
            }

            document.addEventListener('keydown', e => {
                keys[e.code] = true;
                if (e.code === 'KeyR' && gameOver) location.reload();
                // Abrir/fechar inventário e ciclo de armas com Q
                if (e.code === 'KeyQ' && !gameOver && gameStarted) {
                    const inv = document.getElementById('inventory');
                    if (!showInventory) {
                        inv.style.display = 'block';
                        showInventory = true;
                    } else {
                        // Ciclar próxima arma disponível
                        let next = (currentWeapon + 1) % weapons.length;
                        let attempts = 0;
                        while (attempts < weapons.length && !isWeaponAvailable(next)) {
                            next = (next + 1) % weapons.length;
                            attempts++;
                        }
                        selectWeapon(next);
                    }
                }
                // Fechar inventário com X
                if (e.code === 'KeyX' && showInventory) {
                    const inv = document.getElementById('inventory');
                    inv.style.display = 'none';
                    showInventory = false;
                }
                if (e.code === 'KeyT' && !gameOver && gameStarted) {
                    const previousMode = cameraMode;
                    cameraMode = cameraMode === 'first' ? 'third' : 'first';
                    
                    // Gerenciar bloqueio do ponteiro ao alternar modos
                    if (previousMode === 'first' && cameraMode !== 'first') {
                        exitPointerLock();
                    } else if (cameraMode === 'first') {
                        // Resetar orientação da câmera FPS ao entrar no modo
                        fpsCamera.yaw = player.rotation.y;
                        fpsCamera.pitch = 0;
                    }
                }
                if (e.code === 'KeyG' && !gameOver && gameStarted) {
                    cameraMode = cameraMode === 'god' ? 'third' : 'god';
                }
                if (e.code === 'Space') {
                    e.preventDefault(); // impedir comportamento padrão SEMPRE
                }
            });
            document.addEventListener('keyup', e => {
                keys[e.code] = false;
                if (e.code === 'Space') { e.preventDefault(); }
            });

            // Interação com portas (clique no botão vermelho quando perto)
            document.addEventListener('click', () => {
                if (!gameStarted || gameOver || showInventory) return;
                if (!doors || doors.length === 0) return;
                let interacted = false;
                doors.forEach(d => {
                    if (!d || !d.button) return;
                    const dist = player.position.distanceTo(d.button.position);
                    if (dist < 3) {
                        d.isOpen = !d.isOpen;
                        d.autoCloseTimer = d.isOpen ? 240 : 0; // ~4s a 60fps
                        interacted = true;
                    }
                });
                if (interacted) return; // evitar conflito com tiro quando interagir na porta
            });
            // Mouse down/up para suportar fogo contínuo (flame/plasma)
            document.addEventListener('mousedown', () => {
                if (!hasWeapon || gameOver || !gameStarted) return;
                if (showInventory) return;
                isFiring = true;
            });
            document.addEventListener('mouseup', () => {
                isFiring = false;
            });
            
            document.addEventListener('click', () => {
                if (!hasWeapon || gameOver || !gameStarted) return;
                if (showInventory) return; // não atirar com inventário aberto
                fireWeapon();
            });

            // Sistema profissional de controle de mouse para primeira pessoa
            document.addEventListener('mousemove', (e) => {
                if (cameraMode === 'first' && fpsCamera.isLocked) {
                    updateFPSCamera(e.movementX, e.movementY);
                }
            });

            // Solicitar bloqueio de ponteiro para primeira pessoa
            document.addEventListener('click', () => {
                requestPointerLock();
            });

            // Gerenciar mudanças no bloqueio do ponteiro
            document.addEventListener('pointerlockchange', () => {
                fpsCamera.isLocked = document.pointerLockElement === document.body;
                
                // Se sair da primeira pessoa, liberar o bloqueio
                if (cameraMode !== 'first') {
                    exitPointerLock();
                }
            });

            // Liberar bloqueio ao pressionar ESC
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Escape' && fpsCamera.isLocked) {
                    exitPointerLock();
                }
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Inicializar controles mobile
            if (isMobile) {
                initMobileControls();
            }
        }
        
        // Funções de controle mobile
        function initMobileControls() {
            const joystickContainer = document.getElementById('joystickContainer');
            const joystickStick = document.getElementById('joystickStick');
            const jumpBtn = document.getElementById('jumpBtn');
            const shootBtn = document.getElementById('shootBtn');
            const viewBtn = document.getElementById('viewBtn');
            
            // Joystick touch events
            joystickContainer.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = joystickContainer.getBoundingClientRect();
                mobileJoystick.active = true;
                mobileJoystick.startX = rect.left + rect.width / 2;
                mobileJoystick.startY = rect.top + rect.height / 2;
                mobileJoystick.currentX = touch.clientX;
                mobileJoystick.currentY = touch.clientY;
                updateJoystickPosition();
            });
            
            joystickContainer.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!mobileJoystick.active) return;
                const touch = e.touches[0];
                mobileJoystick.currentX = touch.clientX;
                mobileJoystick.currentY = touch.clientY;
                updateJoystickPosition();
            });
            
            joystickContainer.addEventListener('touchend', (e) => {
                e.preventDefault();
                mobileJoystick.active = false;
                mobileJoystick.deltaX = 0;
                mobileJoystick.deltaY = 0;
                joystickStick.style.transform = 'translate(-50%, -50%)';
                // Resetar teclas de movimento
                keys['KeyW'] = false;
                keys['KeyA'] = false;
                keys['KeyS'] = false;
                keys['KeyD'] = false;
            });
            
            // Botão de pulo
            jumpBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys['Space'] = true;
            });
            
            jumpBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys['Space'] = false;
            });
            
            // Botão de atirar
            shootBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (!hasWeapon || gameOver || !gameStarted) return;
                
                // Simular clique para atirar
                const clickEvent = new MouseEvent('click', {
                    view: window,
                    bubbles: true,
                    cancelable: true
                });
                document.dispatchEvent(clickEvent);
            });
            
            // Botão de alternar visão
            viewBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameOver || !gameStarted) return;
                
                const previousMode = cameraMode;
                cameraMode = cameraMode === 'first' ? 'third' : 'first';
                
                if (previousMode === 'first' && cameraMode !== 'first') {
                    exitPointerLock();
                } else if (cameraMode === 'first') {
                    fpsCamera.yaw = player.rotation.y;
                    fpsCamera.pitch = 0;
                }
            });
        }
        
        function updateJoystickPosition() {
            const joystickStick = document.getElementById('joystickStick');
            
            // Calcular delta
            const deltaX = mobileJoystick.currentX - mobileJoystick.startX;
            const deltaY = mobileJoystick.currentY - mobileJoystick.startY;
            
            // Limitar distância máxima do joystick
            const maxDistance = 45;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            if (distance > maxDistance) {
                const angle = Math.atan2(deltaY, deltaX);
                mobileJoystick.deltaX = Math.cos(angle) * maxDistance;
                mobileJoystick.deltaY = Math.sin(angle) * maxDistance;
            } else {
                mobileJoystick.deltaX = deltaX;
                mobileJoystick.deltaY = deltaY;
            }
            
            // Atualizar posição visual do stick
            joystickStick.style.transform = `translate(calc(-50% + ${mobileJoystick.deltaX}px), calc(-50% + ${mobileJoystick.deltaY}px))`;
            
            // Mapear para teclas WASD (normalizado)
            const threshold = 10;
            keys['KeyW'] = mobileJoystick.deltaY < -threshold;
            keys['KeyS'] = mobileJoystick.deltaY > threshold;
            keys['KeyA'] = mobileJoystick.deltaX < -threshold;
            keys['KeyD'] = mobileJoystick.deltaX > threshold;
        }

        // Função para atualizar o tema do mundo (Alien)
        function updateWorldTheme() {
            const alienThemes = [
                { name: 'Corredores Escuros', fog: 0x000000, ambient: 0x000a0a, density: 0.02 },
                { name: 'Vazamento de Ácido', fog: 0x001100, ambient: 0x001a00, density: 0.015 },
                { name: 'Emergência', fog: 0x1a0000, ambient: 0x2a0000, density: 0.018 },
                { name: 'Infestação', fog: 0x0a1a0a, ambient: 0x0a2a0a, density: 0.025 }
            ];

            const theme = alienThemes[worldTheme % alienThemes.length];
            scene.fog = new THREE.FogExp2(theme.fog, theme.density);

            scene.children.forEach(child => {
                if (child instanceof THREE.AmbientLight) {
                    child.color.setHex(theme.ambient);
                    child.intensity = 0.05 + Math.random() * 0.05; // Muito escuro
                }
            });
        }

        // Função para criar tripulante da espaçonave
        function createCrewMember(isInteractive = false) {
            const group = new THREE.Object3D();
            const colors = [0x0066cc, 0x00cc66, 0xcc6600, 0x6600cc, 0xcc0066];
            const color = colors[Math.floor(Math.random() * colors.length)];
            const bodyMat = new THREE.MeshStandardMaterial({ 
                color: color, 
                emissive: color, 
                emissiveIntensity: 0.2 
            });

            const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1, 0.3), bodyMat);
            body.position.y = 0.5;
            group.add(body);

            const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), new THREE.MeshStandardMaterial({ color: 0xf4a261 }));
            head.position.y = 1.2;
            group.add(head);

            // Capacete espacial
            const helmet = new THREE.Mesh(
                new THREE.SphereGeometry(0.25, 16, 16),
                new THREE.MeshStandardMaterial({ 
                    color: 0xcccccc, 
                    transparent: true, 
                    opacity: 0.7,
                    emissive: 0x00d4ff,
                    emissiveIntensity: 0.1
                })
            );
            helmet.position.y = 1.2;
            group.add(helmet);

            if (isInteractive) {
                const label = createLabel('Portal está a ' + (Math.random() > 0.5 ? 'norte' : 'sul'), '#ffffff', 6);
                label.position.y = 2;
                label.visible = false;
                group.add(label);
            }

            return group;
        }

        // Função para criar estrutura principal da espaçonave infectada
        function createAlienSpaceshipStructure(theme) {
            // Paredes externas corroídas e infectadas
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: theme.wall,
                emissive: theme.bioGlow,
                emissiveIntensity: 0.08,
                roughness: 0.8
            });

            // Paredes norte e sul com crescimento orgânico
            for (let i = 0; i < 2; i++) {
                const wall = new THREE.Mesh(
                    new THREE.BoxGeometry(100, 20, 2),
                    wallMaterial
                );
                wall.position.set(0, 10, i === 0 ? -50 : 50);
                buildings.push(wall);
                scene.add(wall);

                // Crescimento orgânico nas paredes
                for (let j = 0; j < 5; j++) {
                    const growth = new THREE.Mesh(
                        new THREE.SphereGeometry(1 + Math.random() * 2, 8, 8),
                        new THREE.MeshStandardMaterial({ 
                            color: theme.organic,
                            emissive: theme.bioGlow,
                            emissiveIntensity: 0.3
                        })
                    );
                    growth.position.set(
                        Math.random() * 80 - 40,
                        5 + Math.random() * 10,
                        i === 0 ? -50.5 : 50.5
                    );
                    scene.add(growth);
                }
            }

            // Paredes leste e oeste
            for (let i = 0; i < 2; i++) {
                const wall = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 20, 100),
                    wallMaterial
                );
                wall.position.set(i === 0 ? -50 : 50, 10, 0);
                buildings.push(wall);
                scene.add(wall);

                // Crescimento orgânico
                for (let j = 0; j < 5; j++) {
                    const growth = new THREE.Mesh(
                        new THREE.SphereGeometry(1 + Math.random() * 2, 8, 8),
                        new THREE.MeshStandardMaterial({ 
                            color: theme.organic,
                            emissive: theme.bioGlow,
                            emissiveIntensity: 0.3
                        })
                    );
                    growth.position.set(
                        i === 0 ? -50.5 : 50.5,
                        5 + Math.random() * 10,
                        Math.random() * 80 - 40
                    );
                    scene.add(growth);
                }
            }

            // Teto corroído com vazamentos
            const ceiling = new THREE.Mesh(
                new THREE.PlaneGeometry(100, 100),
                new THREE.MeshStandardMaterial({ 
                    color: theme.metal,
                    emissive: theme.bioGlow,
                    emissiveIntensity: 0.05,
                    roughness: 0.9
                })
            );
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = 20;
            scene.add(ceiling);

            // Segundo andar com crescimento orgânico
            const secondFloor = new THREE.Mesh(
                new THREE.PlaneGeometry(80, 80),
                new THREE.MeshStandardMaterial({ 
                    color: theme.floor,
                    emissive: theme.bioGlow,
                    emissiveIntensity: 0.08
                })
            );
            secondFloor.rotation.x = -Math.PI / 2;
            secondFloor.position.y = 12;
            scene.add(secondFloor);

            // Adicionar crescimentos orgânicos no segundo andar
            for (let i = 0; i < 8; i++) {
                const organicGrowth = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.5 + Math.random() * 1, 1 + Math.random() * 1.5, 2 + Math.random() * 3, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: theme.organic,
                        emissive: theme.bioGlow,
                        emissiveIntensity: 0.4
                    })
                );
                organicGrowth.position.set(
                    Math.random() * 60 - 30,
                    13,
                    Math.random() * 60 - 30
                );
                scene.add(organicGrowth);
            }
        }

        // Função para criar cômodos infectados da espaçonave
        function createAlienSpaceshipRooms(theme) {
            const roomMaterial = new THREE.MeshStandardMaterial({ 
                color: theme.metal,
                emissive: theme.bioGlow,
                emissiveIntensity: 0.05,
                roughness: 0.8
            });

            // Ponte de comando infectada (centro, segundo andar)
            const bridge = new THREE.Mesh(
                new THREE.BoxGeometry(20, 8, 15),
                roomMaterial
            );
            bridge.position.set(0, 12, 0);
            buildings.push(bridge);
            scene.add(bridge);

            // Engenharia corroída (lado direito, primeiro andar)
            const engineering = new THREE.Mesh(
                new THREE.BoxGeometry(15, 8, 20),
                roomMaterial
            );
            engineering.position.set(25, 4, 0);
            buildings.push(engineering);
            scene.add(engineering);

            // Dormitórios infectados (lado esquerdo, primeiro andar)
            const dormitory = new THREE.Mesh(
                new THREE.BoxGeometry(18, 8, 12),
                roomMaterial
            );
            dormitory.position.set(-25, 4, 0);
            buildings.push(dormitory);
            scene.add(dormitory);

            // Laboratório biológico (fundo, segundo andar)
            const lab = new THREE.Mesh(
                new THREE.BoxGeometry(16, 8, 18),
                roomMaterial
            );
            lab.position.set(0, 12, 25);
            buildings.push(lab);
            scene.add(lab);

            // Armazém com ovos (frente, segundo andar)
            const storage = new THREE.Mesh(
                new THREE.BoxGeometry(14, 8, 16),
                roomMaterial
            );
            storage.position.set(0, 12, -25);
            buildings.push(storage);
            scene.add(storage);

            // Adicionar ovos de Alien no armazém
            for (let i = 0; i < 3; i++) {
                const egg = new THREE.Mesh(
                    new THREE.SphereGeometry(1, 8, 6, 0, Math.PI * 2, 0, Math.PI * 0.8),
                    new THREE.MeshStandardMaterial({ 
                        color: theme.organic,
                        emissive: theme.bioGlow,
                        emissiveIntensity: 0.2
                    })
                );
                egg.scale.set(1.2, 1.5, 1);
                egg.position.set(
                    Math.random() * 10 - 5,
                    12.5,
                    -25 + Math.random() * 12 - 6
                );
                scene.add(egg);
            }

            // Adicionar tecido orgânico nos cômodos
            for (let i = 0; i < 10; i++) {
                const tissue = new THREE.Mesh(
                    new THREE.SphereGeometry(0.5 + Math.random() * 1, 6, 6),
                    new THREE.MeshStandardMaterial({ 
                        color: theme.organic,
                        emissive: theme.bioGlow,
                        emissiveIntensity: 0.3
                    })
                );
                tissue.position.set(
                    Math.random() * 80 - 40,
                    2 + Math.random() * 10,
                    Math.random() * 80 - 40
                );
                scene.add(tissue);
            }
        }

        // Função para criar sistema de elevadores funcionais
        function createFunctionalElevatorSystem(theme) {
            // Criar 3 elevadores funcionais
            const elevatorPositions = [
                [0, 0],    // Centro
                [30, -20], // Lado direito
                [-30, 20]  // Lado esquerdo
            ];

            elevatorPositions.forEach((pos, i) => {
                const elevator = createFunctionalElevator(pos[0], pos[1], true);
                elevators.push(elevator);
                scene.add(elevator);
                
                // Adicionar plataforma aos walkways para colisão
                walkways.push(elevator.platform);
            });
        }

        // Função para criar sistema de portas labirínticas
        function createMazeDoors(theme) {
            // Criar várias portas pela nave
            const doorPositions = [
                [10, 0, 0], [-10, 0, 0],   // Portas norte-sul
                [0, 0, 10], [0, 0, -10],   // Portas leste-oeste
                [20, 0, 20], [-20, 0, -20], // Portas diagonais
                [25, 0, 0], [-25, 0, 0],   // Portas laterais
                [0, 12, 0], [15, 12, 15], [-15, 12, -15] // Portas segundo andar
            ];

            doorPositions.forEach((pos, i) => {
                const door = createDoor(pos[0], pos[1], pos[2]);
                doors.push(door);
                scene.add(door);
                
                // Adicionar porta aos buildings para colisão se fechada
                if (!door.isOpen) {
                    buildings.push(door.door);
                }
            });
        }

        // Função para criar sistema de escadas com crescimento orgânico
        function createAlienStairSystem(theme) {
            const stairMaterial = new THREE.MeshStandardMaterial({ 
                color: theme.metal,
                emissive: theme.bioGlow,
                emissiveIntensity: 0.08,
                roughness: 0.9
            });

            // Escadas principais corroídas (centro-lado)
            for (let i = 0; i < 2; i++) {
                const stairGroup = new THREE.Object3D();
                for (let j = 0; j < 6; j++) {
                    const step = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 0.5, 1.5),
                        stairMaterial
                    );
                    step.position.set(i === 0 ? -15 : 15, j * 0.5, -10 + j * 0.3);
                    stairGroup.add(step);

                    // Adicionar crescimento orgânico nos degraus
                    if (Math.random() > 0.7) {
                        const growth = new THREE.Mesh(
                            new THREE.SphereGeometry(0.3, 6, 6),
                            new THREE.MeshStandardMaterial({ 
                                color: theme.organic,
                                emissive: theme.bioGlow,
                                emissiveIntensity: 0.4
                            })
                        );
                        growth.position.set(
                            i === 0 ? -15 : 15, 
                            j * 0.5 + 0.3, 
                            -10 + j * 0.3
                        );
                        stairGroup.add(growth);
                    }
                }
                stairGroup.position.y = 0;
                scene.add(stairGroup);
                
                // Adicionar cada degrau aos walkways para colisão
                stairGroup.children.forEach(child => {
                    if (child.geometry.type === 'BoxGeometry') {
                        walkways.push(child);
                    }
                });
            }

            // Escadas laterais infectadas (conectando aos elevadores)
            for (let i = 0; i < 2; i++) {
                const sideStairGroup = new THREE.Object3D();
                for (let j = 0; j < 5; j++) {
                    const step = new THREE.Mesh(
                        new THREE.BoxGeometry(1.5, 0.5, 2),
                        stairMaterial
                    );
                    step.position.set(20 + j * 0.3, j * 0.5, i === 0 ? 15 : -15);
                    sideStairGroup.add(step);
                }
                sideStairGroup.position.y = 0;
                scene.add(sideStairGroup);
                
                sideStairGroup.children.forEach(step => {
                    walkways.push(step);
                });
            }
        }

        // Função para criar corredores infectados
        function createAlienCorridors(theme) {
            const corridorMaterial = new THREE.MeshStandardMaterial({ 
                color: theme.wall,
                emissive: theme.bioGlow,
                emissiveIntensity: 0.03,
                roughness: 0.8
            });

            // Corredor horizontal principal infectado (segundo andar)
            const mainCorridor = new THREE.Mesh(
                new THREE.BoxGeometry(60, 8, 4),
                corridorMaterial
            );
            mainCorridor.position.set(0, 12, 0);
            buildings.push(mainCorridor);
            scene.add(mainCorridor);

            // Corredor vertical principal infectado (segundo andar)
            const verticalCorridor = new THREE.Mesh(
                new THREE.BoxGeometry(4, 8, 50),
                corridorMaterial
            );
            verticalCorridor.position.set(0, 12, 0);
            buildings.push(verticalCorridor);
            scene.add(verticalCorridor);

            // Corredores de conexão infectados (primeiro andar)
            const floor1Corridor1 = new THREE.Mesh(
                new THREE.BoxGeometry(20, 8, 4),
                corridorMaterial
            );
            floor1Corridor1.position.set(0, 4, 0);
            buildings.push(floor1Corridor1);
            scene.add(floor1Corridor1);

            const floor1Corridor2 = new THREE.Mesh(
                new THREE.BoxGeometry(4, 8, 30),
                corridorMaterial
            );
            floor1Corridor2.position.set(0, 4, 0);
            buildings.push(floor1Corridor2);
            scene.add(floor1Corridor2);

            // Adicionar vazamentos de ácido nos corredores
            for (let i = 0; i < 6; i++) {
                const acidPool = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.5 + Math.random() * 1, 1 + Math.random() * 1.5, 0.1, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: theme.acid,
                        emissive: theme.acid,
                        emissiveIntensity: 0.6,
                        transparent: true,
                        opacity: 0.8
                    })
                );
                acidPool.position.set(
                    Math.random() * 40 - 20,
                    0.05,
                    Math.random() * 40 - 20
                );
                scene.add(acidPool);
            }
        }

        // Função para criar decorações sombrias da espaçonave infectada
        function createAlienDecorations(theme) {
            // Painéis de controle corroídos
            for (let i = 0; i < 8; i++) {
                const panel = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 3, 0.2),
                    new THREE.MeshStandardMaterial({ 
                        color: theme.metal,
                        emissive: theme.bioGlow,
                        emissiveIntensity: 0.1,
                        roughness: 0.9
                    })
                );
                const positions = [
                    [0, 1.5, 15], [-15, 1.5, 0], [15, 1.5, 0], [0, 1.5, -15],
                    [0, 13.5, 15], [-15, 13.5, 0], [15, 13.5, 0], [0, 13.5, -15]
                ];
                panel.position.set(positions[i][0], positions[i][1], positions[i][2]);
                scene.add(panel);

                // Adicionar crescimento orgânico nos painéis
                if (Math.random() > 0.6) {
                    const growth = new THREE.Mesh(
                        new THREE.SphereGeometry(0.3 + Math.random() * 0.5, 6, 6),
                        new THREE.MeshStandardMaterial({ 
                            color: theme.organic,
                            emissive: theme.bioGlow,
                            emissiveIntensity: 0.5
                        })
                    );
                    growth.position.set(
                        positions[i][0],
                        positions[i][1] + 0.5,
                        positions[i][2]
                    );
                    scene.add(growth);
                }
            }

            // Luzes de emergência piscando (menos luzes, mais atmosfera)
            for (let i = 0; i < 8; i++) {
                const light = new THREE.Mesh(
                    new THREE.SphereGeometry(0.4, 16, 16),
                    new THREE.MeshStandardMaterial({ 
                        color: theme.emergency,
                        emissive: theme.emergency,
                        emissiveIntensity: 0.7
                    })
                );
                const angle = (i / 8) * Math.PI * 2;
                const radius = 35;
                light.position.set(
                    Math.cos(angle) * radius,
                    18,
                    Math.sin(angle) * radius
                );
                scene.add(light);
            }

            // Consoles de computador quebrados
            for (let i = 0; i < 6; i++) {
                const console = new THREE.Mesh(
                    new THREE.BoxGeometry(3, 1.5, 1.5),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x1a1a1a,
                        emissive: theme.bioGlow,
                        emissiveIntensity: 0.15,
                        roughness: 0.9
                    })
                );
                const positions = [
                    [20, 0.75, 10], [-20, 0.75, 10], [20, 0.75, -10],
                    [-20, 0.75, -10], [0, 12.75, 20], [0, 12.75, -20]
                ];
                console.position.set(positions[i][0], positions[i][1], positions[i][2]);
                scene.add(console);
            }

            // Adicionar mais elementos orgânicos espalhados
            for (let i = 0; i < 15; i++) {
                const organicElement = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3 + Math.random() * 0.7, 6, 6),
                    new THREE.MeshStandardMaterial({ 
                        color: theme.organic,
                        emissive: theme.bioGlow,
                        emissiveIntensity: 0.3 + Math.random() * 0.4
                    })
                );
                organicElement.position.set(
                    Math.random() * 80 - 40,
                    1 + Math.random() * 15,
                    Math.random() * 80 - 40
                );
                scene.add(organicElement);
            }

            // Adicionar mais vazamentos de ácido
            for (let i = 0; i < 10; i++) {
                const acidLeak = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2, 0.8, 0.05, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: theme.acid,
                        emissive: theme.acid,
                        emissiveIntensity: 0.8,
                        transparent: true,
                        opacity: 0.9
                    })
                );
                acidLeak.position.set(
                    Math.random() * 60 - 30,
                    0.025,
                    Math.random() * 60 - 30
                );
                scene.add(acidLeak);
            }
        }

        // Função para gerar o mundo da espaçonave
        function generateWorld() {
            buildings.forEach(b => scene.remove(b));
            enemies.forEach(e => scene.remove(e.mesh));
            vehicles.forEach(v => scene.remove(v.mesh));
            pickups.forEach(p => scene.remove(p.mesh));
            pedestrians.forEach(p => scene.remove(p.mesh));
            sidewalks.forEach(s => scene.remove(s));
            roads.forEach(r => scene.remove(r));
            walkways.forEach(w => scene.remove(w));
            ramps.forEach(r => scene.remove(r));
            if (train) scene.remove(train.mesh);
            if (safeZone) scene.remove(safeZone);
            if (portal) scene.remove(portal);

            buildings = [];
            enemies = [];
            vehicles = [];
            pickups = [];
            pedestrians = [];
            sidewalks = [];
            roads = [];
            walkways = [];
            ramps = [];
            train = null;

            worldTheme++;
            updateWorldTheme();

            // Tema Alien - escuro e orgânico
            const alienTheme = {
                floor: 0x0a0a0a,
                wall: 0x1a1a1a,
                metal: 0x2a2a2a,
                organic: 0x4a2a1a,
                blood: 0x8b0000,
                acid: 0x00ff00,
                emergency: 0xff0000,
                bioGlow: 0x004400
            };

            // Chão base da espaçonave infectada
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(200, 200),
                new THREE.MeshStandardMaterial({ 
                    color: alienTheme.floor,
                    emissive: alienTheme.bioGlow,
                    emissiveIntensity: 0.05
                })
            );
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);

            // Criar estrutura principal da espaçonave infectada
            createAlienSpaceshipStructure(alienTheme);

            // Criar cômodos infectados
            createAlienSpaceshipRooms(alienTheme);

            // Criar sistema de elevadores funcionais
            createFunctionalElevatorSystem(alienTheme);

            // Adicionar elevador simples (plataforma roxa) próximo ao centro
            const simpleElevator = createFunctionalElevator(6, -6, true);
            elevators.push(simpleElevator);
            scene.add(simpleElevator);

            // Adicionar porta em uma parede próxima ao spawn (frente do jogador)
            const door = createDoor(6, 2, -10, 3, 4.5, 0.2, false);
            // Trancar esta porta para "fechar" a área
            door.isLocked = true;
            if (door.button && door.button.material) {
                door.button.material.color.set(0x550000);
                door.button.material.emissive.set(0x550000);
                door.button.material.emissiveIntensity = 0.2;
            }
            // Garantir colisão da folha da porta
            buildings.push(door.door);
            doors.push(door);
            scene.add(door);

            // Selar o entorno da porta com painéis adicionais (fechar o lugar)
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: alienTheme.wall,
                emissive: alienTheme.bioGlow,
                emissiveIntensity: 0.06,
                roughness: 0.85
            });
            const sealFront = new THREE.Mesh(new THREE.BoxGeometry(22, 10, 2), wallMaterial);
            sealFront.position.set(6, 4, -16);
            buildings.push(sealFront);
            scene.add(sealFront);
            const sealLeft = new THREE.Mesh(new THREE.BoxGeometry(2, 10, 16), wallMaterial);
            sealLeft.position.set(6 - 12, 5, -10);
            buildings.push(sealLeft);
            scene.add(sealLeft);
            const sealRight = new THREE.Mesh(new THREE.BoxGeometry(2, 10, 16), wallMaterial);
            sealRight.position.set(6 + 12, 5, -10);
            buildings.push(sealRight);
            scene.add(sealRight);

            // Teto para esconderijo
            const sealTop = new THREE.Mesh(new THREE.BoxGeometry(22, 2, 16), wallMaterial);
            sealTop.position.set(6, 9.5, -10);
            buildings.push(sealTop);
            scene.add(sealTop);

            // Criar escadas com crescimento orgânico
            createAlienStairSystem(alienTheme);

            // Segundo andar: piso com buracos e passagens
            // Criar ladrilhos de piso no y=12 e deixar buracos para acesso ao andar de baixo
            const floorY = 12;
            const tileSize = 18;
            const gridRange = [-2, -1, 0, 1, 2]; // 5x5
            const holes = new Set(['0,0', '1,-1', '-1,1']); // buracos em posições escolhidas
            const secondFloorMaterial = new THREE.MeshStandardMaterial({
                color: alienTheme.floor,
                emissive: alienTheme.bioGlow,
                emissiveIntensity: 0.06,
                roughness: 0.9
            });
            gridRange.forEach(ix => {
                gridRange.forEach(iz => {
                    const key = `${ix},${iz}`;
                    if (holes.has(key)) return; // deixar buraco
                    const tile = new THREE.Mesh(
                        new THREE.BoxGeometry(tileSize, 0.6, tileSize),
                        secondFloorMaterial
                    );
                    tile.position.set(ix * tileSize, floorY, iz * tileSize);
                    scene.add(tile);
                    // Adicionar como passarela para colisão
                    walkways.push(tile);
                });
            });

            // Escada alta até o teto (acesso entre andares e além)
            const highStair = new THREE.Object3D();
            for (let i = 0; i < 24; i++) {
                const step = new THREE.Mesh(
                    new THREE.BoxGeometry(1.8, 0.5, 2),
                    new THREE.MeshStandardMaterial({ color: alienTheme.metal, emissive: alienTheme.bioGlow, emissiveIntensity: 0.06 })
                );
                step.position.set(28 + i * 0.25, 2 + i * 0.45, -18);
                highStair.add(step);
                walkways.push(step);
            }
            scene.add(highStair);

            // Criar corredores infectados
            createAlienCorridors(alienTheme);

            // Criar sistema de portas labirínticas
            createMazeDoors(alienTheme);

            // Adicionar elementos orgânicos e biológicos
            createAlienDecorations(alienTheme);

            // Definir pontos de spawn controlado (térreo e segundo andar)
            enemySpawnPoints = [
                new THREE.Vector3(-30, 2, -30), new THREE.Vector3(30, 2, -30),
                new THREE.Vector3(-30, 2, 30), new THREE.Vector3(30, 2, 30),
                new THREE.Vector3(0, 2, 40), new THREE.Vector3(40, 2, 0)
            ];
            enemySpawnPoints2F = [
                new THREE.Vector3(-18, 12, -18), new THREE.Vector3(18, 12, -18),
                new THREE.Vector3(-18, 12, 18), new THREE.Vector3(18, 12, 18)
            ];

            // Criar drones/robôs da espaçonave (substituindo carros)
            for (let i = 0; i < 6; i++) {
                const droneGroup = new THREE.Object3D();
                const drone = new THREE.Mesh(
                    new THREE.BoxGeometry(4, 2, 4),
                    new THREE.MeshStandardMaterial({ 
                        color: alienTheme.metal,
                        emissive: alienTheme.bioGlow,
                        emissiveIntensity: 0.3
                    })
                );
                drone.position.y = 1;
                droneGroup.add(drone);

                // Propulsores do drone
                const thrusterMat = new THREE.MeshStandardMaterial({ 
                    color: 0xff6600,
                    emissive: 0xff6600,
                    emissiveIntensity: 0.8
                });

                const thruster1 = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, 0.5, 8), thrusterMat);
                thruster1.position.set(-1.5, 0.5, -1.5);
                droneGroup.add(thruster1);

                const thruster2 = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, 0.5, 8), thrusterMat);
                thruster2.position.set(1.5, 0.5, -1.5);
                droneGroup.add(thruster2);

                const thruster3 = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, 0.5, 8), thrusterMat);
                thruster3.position.set(-1.5, 0.5, 1.5);
                droneGroup.add(thruster3);

                const thruster4 = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, 0.5, 8), thrusterMat);
                thruster4.position.set(1.5, 0.5, 1.5);
                droneGroup.add(thruster4);

                droneGroup.position.set(
                    (Math.random() * 2 - 1) * 40, 
                    Math.random() * 10 + 5,
                    (Math.random() * 2 - 1) * 40
                );
                vehicles.push({
                    mesh: droneGroup,
                    wheels: [thruster1, thruster2, thruster3, thruster4],
                    speed: (Math.random() * 0.15 + 0.1) * (Math.random() > 0.5 ? 1 : -1),
                    axis: 'x'
                });
                scene.add(droneGroup);
            }

            // Criar Xenomorphs (Alien) - piso térreo
            for (let i = 0; i < 4 + level * 2; i++) {
                const xenomorph = createXenomorph();
                const a = Math.random() * Math.PI * 2;
                const dist = Math.random() * 40 + 20;
                xenomorph.position.set(Math.cos(a) * dist, 0, Math.sin(a) * dist);
                enemies.push({
                    mesh: xenomorph,
                    speed: 0.06 + level * 0.015,
                    health: 8,
                    biteAnimation: 0,
                    isDead: false
                });
                scene.add(xenomorph);
            }

            // Criar Xenomorphs no segundo andar
            for (let i = 0; i < 2 + level; i++) {
                const x = (Math.random() * 4 - 2) * 18; // alinhado aos ladrilhos
                const z = (Math.random() * 4 - 2) * 18;
                const xenomorph = createXenomorph();
                xenomorph.position.set(x, 12, z);
                enemies.push({ mesh: xenomorph, speed: 0.06 + level * 0.015, health: 8, biteAnimation: 0, isDead: false });
                scene.add(xenomorph);
            }

            // Criar Facehuggers (menores, mais numerosos) - térreo
            for (let i = 0; i < 8 + level * 3; i++) {
                const facehugger = createFacehugger();
                const a = Math.random() * Math.PI * 2;
                const dist = Math.random() * 30 + 15;
                facehugger.position.set(Math.cos(a) * dist, 0.15, Math.sin(a) * dist);
                enemies.push({
                    mesh: facehugger,
                    speed: 0.08 + level * 0.01,
                    health: 3,
                    biteAnimation: 0,
                    isDead: false
                });
                scene.add(facehugger);
            }

            // Facehuggers no segundo andar
            for (let i = 0; i < 4 + level; i++) {
                const fh = createFacehugger();
                fh.position.set((Math.random()*4-2)*18, 12.2, (Math.random()*4-2)*18);
                enemies.push({ mesh: fh, speed: 0.08 + level * 0.01, health: 3, biteAnimation: 0, isDead: false });
                scene.add(fh);
            }

            // Criar Vespas (voadoras e rápidas)
            for (let i = 0; i < 3 + level; i++) {
                const wasp = createWasp();
                const a = Math.random() * Math.PI * 2;
                const dist = Math.random() * 40 + 20;
                wasp.position.set(Math.cos(a) * dist, 6 + Math.random() * 8, Math.sin(a) * dist);
                enemies.push({ mesh: wasp, speed: 0.12 + level * 0.02, health: 4, biteAnimation: 0, isDead: false, isWasp: true });
                scene.add(wasp);
            }

            // Criar Boss (Alien Queen) - apenas um por nível
            if (level % 3 === 0) {
                const alienBoss = createAlienBoss();
                alienBoss.position.set(0, 0, 0); // Centro da nave
                boss = {
                    mesh: alienBoss,
                    speed: 0.12, // Mais rápido que Xenomorphs normais
                    health: 20,
                    biteAnimation: 0,
                    isDead: false,
                    isBoss: true
                };
                enemies.push(boss);
                scene.add(alienBoss);
            }

            // Criar tripulantes da espaçonave (substituindo pedestres)
            for (let i = 0; i < 12; i++) {
                const isInteractive = Math.random() > 0.7;
                const crewMember = createCrewMember(isInteractive);
                crewMember.position.set(
                    Math.random() * 60 - 30,
                    2, // Andar principal
                    Math.random() * 60 - 30
                );
                const walkDir = Math.random() * Math.PI * 2;
                pedestrians.push({
                    mesh: crewMember,
                    direction: walkDir,
                    speed: 0.03 + Math.random() * 0.02,
                    walkCycle: Math.random() * 10,
                    isInteractive
                });
                scene.add(crewMember);
            }

            // Criar itens da espaçonave (térreo)
            for (let i = 0; i < 15; i++) {
                const type = Math.random();
                let pickup;
                let label;
                if (type > 0.95) {
                    // Laser Gun (arma padrão)
                    pickup = new THREE.Mesh(
                        new THREE.BoxGeometry(0.8, 0.3, 1.2),
                        new THREE.MeshStandardMaterial({ 
                            color: 0x00ff88, 
                            emissive: 0x00ff88, 
                            emissiveIntensity: 1.2 
                        })
                    );
                    label = createLabel('LASER GUN', '#00ff00');
                    pickup.type = 'weapon';
                } else if (type > 0.85) {
                    // Granadas
                    pickup = new THREE.Mesh(
                        new THREE.SphereGeometry(0.4, 8, 8),
                        new THREE.MeshStandardMaterial({ 
                            color: 0xff8c42, 
                            emissive: 0xff8c42, 
                            emissiveIntensity: 1.2 
                        })
                    );
                    label = createLabel('GRANADAS', '#ff6600');
                    pickup.type = 'grenades';
                } else if (type > 0.75) {
                    // Minas
                    pickup = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.5, 0.5, 0.3, 8),
                        new THREE.MeshStandardMaterial({ 
                            color: 0xffd93d, 
                            emissive: 0xffd93d, 
                            emissiveIntensity: 1.2 
                        })
                    );
                    label = createLabel('MINAS', '#ffff00');
                    pickup.type = 'mines';
                } else if (type > 0.65) {
                    // Lança-chamas
                    pickup = new THREE.Mesh(
                        new THREE.BoxGeometry(1.5, 0.3, 0.8),
                        new THREE.MeshStandardMaterial({ 
                            color: 0xff4757, 
                            emissive: 0xff4757, 
                            emissiveIntensity: 1.2 
                        })
                    );
                    label = createLabel('LANÇA-CHAMAS', '#ff0000');
                    pickup.type = 'flamethrower';
                } else if (type > 0.55) {
                    // Bazuca de energia
                    pickup = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 0.4, 0.6),
                        new THREE.MeshStandardMaterial({ 
                            color: 0x00d2ff, 
                            emissive: 0x00d2ff, 
                            emissiveIntensity: 1.2 
                        })
                    );
                    label = createLabel('BAZUCA PLASMA', '#00ffff');
                    pickup.type = 'plasma_launcher';
                } else if (type > 0.45) {
                    // Kit médico
                    pickup = createRedCross();
                    label = createLabel('MED KIT', '#ff0000');
                    pickup.type = 'health';
                } else if (type > 0.25) {
                    // Ração espacial
                    pickup = new THREE.Mesh(
                        new THREE.BoxGeometry(0.8, 0.8, 0.8),
                        new THREE.MeshStandardMaterial({ 
                            color: 0xffb347, 
                            emissive: 0xffb347, 
                            emissiveIntensity: 1.2 
                        })
                    );
                    label = createLabel('RATIONS', '#ffa500');
                    pickup.type = 'food';
                } else {
                    // Bateria de energia
                    pickup = new THREE.Mesh(
                        new THREE.BoxGeometry(1, 1.5, 0.5),
                        new THREE.MeshStandardMaterial({ 
                            color: 0x00b4d8, 
                            emissive: 0x00b4d8, 
                            emissiveIntensity: 1.2 
                        })
                    );
                    label = createLabel('ENERGY CELL', '#00d4ff');
                    pickup.type = 'energy';
                }
                pickup.position.set(Math.random() * 60 - 30, 1, Math.random() * 60 - 30);
                label.position.y = 2.5;
                pickup.add(label);
                pickups.push({ mesh: pickup, type: pickup.type, rotation: 0 });
                scene.add(pickup);
            }

            // Itens no segundo andar
            for (let i = 0; i < 8; i++) {
                const type = Math.random();
                let pickup;
                let label;
                if (type > 0.7) {
                    // Granadas
                    pickup = new THREE.Mesh(
                        new THREE.SphereGeometry(0.4, 8, 8),
                        new THREE.MeshStandardMaterial({ color: 0xff8c42, emissive: 0xff8c42, emissiveIntensity: 1.2 })
                    );
                    label = createLabel('GRANADAS', '#ff6600');
                    pickup.type = 'grenades';
                } else if (type > 0.5) {
                    // Lança-chamas
                    pickup = new THREE.Mesh(
                        new THREE.BoxGeometry(1.5, 0.3, 0.8),
                        new THREE.MeshStandardMaterial({ color: 0xff4757, emissive: 0xff4757, emissiveIntensity: 1.2 })
                    );
                    label = createLabel('LANÇA-CHAMAS', '#ff0000');
                    pickup.type = 'flamethrower';
                } else if (type > 0.3) {
                    // Bazuca
                    pickup = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 0.4, 0.6),
                        new THREE.MeshStandardMaterial({ color: 0x00d2ff, emissive: 0x00d2ff, emissiveIntensity: 1.2 })
                    );
                    label = createLabel('BAZUCA PLASMA', '#00ffff');
                    pickup.type = 'plasma_launcher';
                } else {
                    // Laser Gun
                    pickup = new THREE.Mesh(
                        new THREE.BoxGeometry(0.8, 0.3, 1.2),
                        new THREE.MeshStandardMaterial({ color: 0x00ff88, emissive: 0x00ff88, emissiveIntensity: 1.2 })
                    );
                    label = createLabel('LASER GUN', '#00ff00');
                    pickup.type = 'weapon';
                }
                const gx = (Math.random()*4-2)*18;
                const gz = (Math.random()*4-2)*18;
                pickup.position.set(gx, 13, gz);
                label.position.y = 2.5;
                pickup.add(label);
                pickups.push({ mesh: pickup, type: pickup.type, rotation: 0 });
                scene.add(pickup);
            }

            // CANOS ESTOURADOS COM FAÍSCAS
            window.sparks = [];
            for (let i = 0; i < 6; i++) {
                const pipe = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.4, 0.4, 6, 10),
                    new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.8, roughness: 0.4 })
                );
                const px = 0; // fixar no eixo X=0
                const pz = Math.random() * 60 - 30;
                pipe.position.set(px, 6 + Math.random() * 8, pz);
                pipe.rotation.z = Math.random() * 0.6 - 0.3;
                scene.add(pipe);

                // Emissor de faíscas (partículas simples)
                const sparkGeom = new THREE.BufferGeometry();
                const sparkCount = 40;
                const positions = new Float32Array(sparkCount * 3);
                for (let s = 0; s < sparkCount; s++) {
                    positions[s*3] = 0;
                    positions[s*3+1] = 0;
                    positions[s*3+2] = 0;
                }
                sparkGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const sparkMat = new THREE.PointsMaterial({ color: 0xffdd88, size: 0.1, transparent: true, opacity: 0.9 });
                const sparkPoints = new THREE.Points(sparkGeom, sparkMat);
                sparkPoints.position.set(px, pipe.position.y + 3, pz);
                scene.add(sparkPoints);
                const velocities = [];
                for (let s = 0; s < sparkCount; s++) {
                    velocities.push(new THREE.Vector3((Math.random()-0.5)*0.2, Math.random()*0.4, (Math.random()-0.5)*0.2));
                }
                window.sparks.push({ points: sparkPoints, velocities, life: 60 + Math.floor(Math.random()*60) });
            }

            // MONITORES COM IMAGENS DOS ALIENS (canvas dinâmico)
            window.alienMonitors = [];
            for (let i = 0; i < 5; i++) {
                const canvas = document.createElement('canvas');
                canvas.width = 128; canvas.height = 96;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#0a0f12';
                ctx.fillRect(0,0,canvas.width,canvas.height);
                ctx.fillStyle = '#00ff88';
                ctx.font = 'bold 16px monospace';
                ctx.fillText('ALIEN FEED', 12, 20);
                // Desenhar silhueta simples
                ctx.strokeStyle = '#00ff88';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(64, 56, 20, 0, Math.PI*2);
                ctx.moveTo(44, 66); ctx.lineTo(84, 66);
                ctx.moveTo(64, 36); ctx.lineTo(64, 76);
                ctx.stroke();

                const tex = new THREE.CanvasTexture(canvas);
                tex.minFilter = THREE.LinearFilter;
                const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.FrontSide });
                const screen = new THREE.Mesh(new THREE.PlaneGeometry(8, 6), mat);
                const mx = Math.random() * 60 - 30;
                const mz = Math.random() * 60 - 30;
                screen.position.set(mx, 10 + Math.random()*4, mz);
                screen.lookAt(0, screen.position.y, 0);
                scene.add(screen);
                window.alienMonitors.push({ canvas, ctx, tex, mesh: screen, tick: 0 });
            }

            // Portal de evacuação da espaçonave
            safeZone = new THREE.Mesh(
                new THREE.BoxGeometry(8, 8, 8),
                new THREE.MeshStandardMaterial({ 
                    color: 0x00ff00, 
                    emissive: 0x00ff00, 
                    emissiveIntensity: 0.5, 
                    transparent: true, 
                    opacity: 0.6 
                })
            );
            const sa = Math.random() * Math.PI * 2;
            const sd = Math.random() * 50 + 40;
            safeZone.position.set(Math.cos(sa) * sd, 4, Math.sin(sa) * sd);
            scene.add(safeZone);

            // Portal de evacuação espacial
            portal = new THREE.Object3D();
            const portalRings = 5;
            for (let i = 0; i < portalRings; i++) {
                const ring = new THREE.Mesh(
                    new THREE.TorusGeometry(3 - i * 0.4, 0.15, 16, 32),
                    new THREE.MeshStandardMaterial({
                        color: 0x00ffff,
                        emissive: 0x00ffff,
                        emissiveIntensity: 1,
                        transparent: true,
                        opacity: 0.7 - i * 0.1
                    })
                );
                ring.rotation.y = (i * Math.PI) / portalRings;
                portal.add(ring);
            }

            const core = new THREE.Mesh(
                new THREE.SphereGeometry(1.5, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0x00ffff,
                    emissive: 0x00ffff,
                    emissiveIntensity: 1.5,
                    transparent: true,
                    opacity: 0.5
                })
            );
            portal.add(core);

            const exitLabel = createLabel('ESCAPE POD', '#00ffff', 8);
            exitLabel.position.y = 5;
            portal.add(exitLabel);

            portal.position.copy(safeZone.position);
            portal.position.y = 4;
            scene.add(portal);
        }

        // Função para verificar colisão (sem mudanças)
        function checkCollision(x, z, y = player.position.y) {
            const r = 1.5;
            for (let b of buildings) {
                const box = new THREE.Box3().setFromObject(b);
                const pBox = new THREE.Box3(
                    new THREE.Vector3(x - r, y - 1, z - r),
                    new THREE.Vector3(x + r, y + 2, z + r)
                );
                if (box.intersectsBox(pBox)) return true;
            }
            for (let v of vehicles) {
                const box = new THREE.Box3().setFromObject(v.mesh);
                const pBox = new THREE.Box3(
                    new THREE.Vector3(x - r, y - 1, z - r),
                    new THREE.Vector3(x + r, y + 2, z + r)
                );
                if (box.intersectsBox(pBox)) return true;
            }
            for (let w of walkways) {
                const box = new THREE.Box3().setFromObject(w);
                const pBox = new THREE.Box3(
                    new THREE.Vector3(x - r, y - 1, z - r),
                    new THREE.Vector3(x + r, y + 2, z + r)
                );
                if (box.intersectsBox(pBox)) {
                    player.position.y = w.position.y + 1.5;
                    return false;
                }
            }
            for (let r of ramps) {
                const box = new THREE.Box3().setFromObject(r);
                const pBox = new THREE.Box3(
                    new THREE.Vector3(x - r, y - 1, z - r),
                    new THREE.Vector3(x + r, y + 2, z + r)
                );
                if (box.intersectsBox(pBox)) {
                    player.position.y = r.position.y + 1.5;
                    return false;
                }
            }
            return false;
        }

        // Função para ajustar câmera para evitar obstruções (sem mudanças)
        function adjustCameraForObstructions() {
            if (cameraMode !== 'third') return;

            const playerHead = new THREE.Vector3(player.position.x, player.position.y + 1, player.position.z);
            const cameraPos = camera.position.clone();

            raycaster.set(cameraPos, playerHead.clone().sub(cameraPos).normalize());
            const intersects = raycaster.intersectObjects(buildings, true);

            if (intersects.length > 0) {
                // Se houver obstrução, elevar a câmera
                cameraOffset = Math.min(cameraOffset + 0.5, 10); // Limite de elevação
                camera.position.y += 0.5;
            } else {
                cameraOffset = Math.max(cameraOffset - 0.3, 0); // Reduzir elevação gradualmente
                camera.position.y -= 0.3;
            }
        }

        // Função de atualização do jogo (sem mudanças)
        // Função para spawnar jogador em nova posição
        function spawnPlayer() {
            const spawnPoints = [
                { x: Math.random() * 40 - 20, y: 2, z: Math.random() * 40 - 20 },
                { x: Math.random() * 40 - 20, y: 12, z: Math.random() * 40 - 20 },
                { x: 0, y: 2, z: 0 },
                { x: 15, y: 12, z: 15 },
                { x: -15, y: 12, z: -15 }
            ];
            
            const spawnPoint = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
            player.position.set(spawnPoint.x, spawnPoint.y, spawnPoint.z);
            velocity.set(0, 0, 0);
            health = Math.min(100, health + 20); // Recuperar um pouco de vida
            stamina = Math.min(100, stamina + 30); // Recuperar stamina
        }

        function update() {
            if (gameOver) return;
            
            // Atualizar cronômetro
            gameTimer -= 1/60; // Assumindo 60 FPS
            if (gameTimer <= 0) {
                // Fim de rodada: avaliar vencedor e reset leve
                const remaining = enemies.filter(e => !e.isDead).length;
                let message = '';
                if (remaining === 0) {
                    // Limparam a fase: parceiro vira hostil
                    partnerHostile = true;
                    message = 'Todos os bichos mortos: parceiro virou inimigo!';
                } else {
                    // Mostrar placar
                    message = `Tempo esgotado. Player ${playerKills} x ${partnerKills} Partner`;
                }
                alert(message);
                // Reset timer e respawn leve
                gameTimer = 600;
                spawnPlayer();
            }
            
            // Atualizar display do cronômetro
            const minutes = Math.floor(gameTimer / 60);
            const seconds = Math.floor(gameTimer % 60);
            document.getElementById('timer').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;

            // Atualizar faíscas
            if (window.sparks) {
                window.sparks.forEach((emitter) => {
                    const geom = emitter.points.geometry;
                    const pos = geom.attributes.position;
                    for (let i = 0; i < pos.count; i++) {
                        emitter.velocities[i].y -= 0.01;
                        pos.setX(i, pos.getX(i) + emitter.velocities[i].x);
                        pos.setY(i, pos.getY(i) + emitter.velocities[i].y);
                        pos.setZ(i, pos.getZ(i) + emitter.velocities[i].z);
                        // Desaparecer
                        if (pos.getY(i) < -1) {
                            pos.setX(i, 0);
                            pos.setY(i, 0);
                            pos.setZ(i, 0);
                            emitter.velocities[i].set((Math.random()-0.5)*0.2, Math.random()*0.4, (Math.random()-0.5)*0.2);
                        }
                    }
                    pos.needsUpdate = true;
                    emitter.life--;
                    if (emitter.life <= 0) {
                        emitter.life = 60 + Math.floor(Math.random()*60);
                    }
                });
            }

            // Atualizar monitores (efeito flicker)
            if (window.alienMonitors) {
                window.alienMonitors.forEach(m => {
                    m.tick++;
                    if (m.tick % 30 === 0) {
                        const c = m.canvas, ctx = m.ctx;
                        ctx.fillStyle = '#0a0f12';
                        ctx.fillRect(0,0,c.width,c.height);
                        ctx.fillStyle = Math.random() > 0.5 ? '#00ff88' : '#00d2ff';
                        ctx.font = 'bold 16px monospace';
                        ctx.fillText('ALIEN FEED', 12, 20);
                        ctx.strokeStyle = ctx.fillStyle;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        const r = 18 + Math.random()*6;
                        ctx.arc(64, 56, r, 0, Math.PI*2);
                        ctx.moveTo(44, 66); ctx.lineTo(84, 66);
                        ctx.moveTo(64, 36); ctx.lineTo(64, 76);
                        ctx.stroke();
                        m.tex.needsUpdate = true;
                    }
                });
            }

            // Spawner controlado: atraso entre spawns e limite de inimigos
            spawnTimer += 1/60;
            const alive = enemies.filter(e => !e.isDead).length;
            if (spawnTimer >= nextSpawnDelay && alive < maxConcurrentEnemies) {
                spawnTimer = 0;
                nextSpawnDelay = 6 + Math.random() * 6; // 6-12s entre spawns
                const use2F = Math.random() < 0.4 && enemySpawnPoints2F.length > 0; // às vezes no 2º andar
                const points = use2F ? enemySpawnPoints2F : enemySpawnPoints;
                const p = points[Math.floor(Math.random() * points.length)];
                const roll = Math.random();
                let ent;
                if (roll < 0.2) {
                    ent = createWasp();
                    ent.position.copy(p.clone()); ent.position.y += use2F ? 2 : 5;
                    enemies.push({ mesh: ent, speed: 0.12 + level * 0.02, health: 4, biteAnimation: 0, isDead: false, isWasp: true });
                } else if (roll < 0.6) {
                    ent = createFacehugger();
                    ent.position.copy(p.clone()); if (!use2F) ent.position.y = 0.15; else ent.position.y = 12.2;
                    enemies.push({ mesh: ent, speed: 0.08 + level * 0.01, health: 3, biteAnimation: 0, isDead: false });
                } else {
                    ent = createXenomorph();
                    ent.position.copy(p.clone()); if (use2F) ent.position.y = 12;
                    enemies.push({ mesh: ent, speed: 0.06 + level * 0.015, health: 8, biteAnimation: 0, isDead: false });
                }
                scene.add(ent);
            }

            const isRunning = keys['ShiftLeft'] || keys['ShiftRight'];
            const baseSpeed = isRunning ? 0.25 : 0.15;
            const speed = stamina > 0 ? baseSpeed : baseSpeed * 0.5;
            let moving = false;
            let moveX = 0, moveZ = 0;

            if (isInTrain) {
                player.position.copy(train.mesh.position);
                player.position.y = 2;
                cameraMode = 'third';
            } else {
                if (cameraMode === 'god') {
                    // Inverter W e S na visão top down
                    if (keys['KeyW']) moveZ = -1; // Invertido
                    if (keys['KeyS']) moveZ = 1;  // Invertido
                    if (keys['KeyA']) moveX = -1;
                    if (keys['KeyD']) moveX = 1;
                } else if (cameraMode === 'first') {
                    // Movimento profissional baseado na câmera FPS
                    const { forward, right } = getFPSMovementDirection();
                    
                    if (keys['KeyW']) {
                        moveX += forward.x;
                        moveZ += forward.z;
                    }
                    if (keys['KeyS']) {
                        moveX -= forward.x;
                        moveZ -= forward.z;
                    }
                    if (keys['KeyA']) {
                        moveX -= right.x;
                        moveZ -= right.z;
                    }
                    if (keys['KeyD']) {
                        moveX += right.x;
                        moveZ += right.z;
                    }
                } else {
                    if (keys['KeyW']) moveZ = 1;
                    if (keys['KeyS']) moveZ = -1;
                    if (keys['KeyA']) moveX = 1;
                    if (keys['KeyD']) moveX = -1;
                }
                if (moveX !== 0 || moveZ !== 0) moving = true;

                if (moving) {
                    const nx = player.position.x + moveX * speed;
                    const nz = player.position.z + moveZ * speed;
                    // DESABILITAR checkCollision temporariamente para testar
                    player.position.x = nx;
                    player.position.z = nz;

                    // Só rotacionar o personagem se não estiver em primeira pessoa
                    if (cameraMode !== 'first') {
                        const targetAngle = Math.atan2(moveX, moveZ);
                        player.rotation.y = targetAngle;
                    }

                    // Drenar stamina ao se mover (maior drenagem correndo)
                    const drain = isRunning ? 0.08 : 0.03; // ~4.8/s correndo, ~1.8/s andando
                    stamina = Math.max(0, stamina - drain);
                } else {
                    // Sem regeneração passiva — recuperar apenas com ENERGY CELL ou FOOD
                }
            }

            // Movimento simples do parceiro (segue pontos aleatórios, com gravidade e colisão de passarelas)
            if (partner) {
                if (!partner.userData.target || partner.position.distanceTo(partner.userData.target) < 1) {
                    partner.userData.target = new THREE.Vector3(
                        Math.random() * 80 - 40,
                        0,
                        Math.random() * 80 - 40
                    );
                }
                const pdir = new THREE.Vector3().subVectors(partner.userData.target, partner.position).normalize();
                const pspeed = 0.12;
                const pnx = partner.position.x + pdir.x * pspeed;
                const pnz = partner.position.z + pdir.z * pspeed;
                partner.position.x = pnx;
                partner.position.z = pnz;
                partnerVelocity.y -= 0.02;
                partner.position.y += partnerVelocity.y;
                // Colisão com walkways
                const pBox = new THREE.Box3(
                    new THREE.Vector3(partner.position.x - 1.2, partner.position.y - 1, partner.position.z - 1.2),
                    new THREE.Vector3(partner.position.x + 1.2, partner.position.y + 2, partner.position.z + 1.2)
                );
                let partnerOnGround = false;
                for (let w of walkways) {
                    const wBox = new THREE.Box3().setFromObject(w);
                    if (wBox.intersectsBox(pBox)) {
                        partner.position.y = w.position.y + 1.5;
                        partnerVelocity.y = 0;
                        partnerOnGround = true;
                        break;
                    }
                }
                if (!partnerOnGround && partner.position.y <= 2.1) {
                    partner.position.y = 2;
                    partnerVelocity.y = 0;
                }
                // Olhar para direção do movimento
                partner.rotation.y = Math.atan2(pdir.x, pdir.z);
            }

            // SISTEMA IGUAL ÀS PASSARELAS - FUNCIONA EM TODO LUGAR!
            
            // Aplicar gravidade
            velocity.y -= 0.02;
            player.position.y += velocity.y;
            
            // Detecção de chão igual às passarelas - usando checkCollision
            const playerBox = new THREE.Box3(
                new THREE.Vector3(player.position.x - 1.5, player.position.y - 1, player.position.z - 1.5),
                new THREE.Vector3(player.position.x + 1.5, player.position.y + 2, player.position.z + 1.5)
            );
            
            let onGround = false;
            
            // Verificar passarelas (funciona)
            for (let w of walkways) {
                const walkwayBox = new THREE.Box3().setFromObject(w);
                if (walkwayBox.intersectsBox(playerBox)) {
                    player.position.y = w.position.y + 1.5;
                    velocity.y = 0;
                    onGround = true;
                    break;
                }
            }
            
            // Verificar rampas
            if (!onGround) {
                for (let r of ramps) {
                    const rampBox = new THREE.Box3().setFromObject(r);
                    if (rampBox.intersectsBox(playerBox)) {
                        player.position.y = r.position.y + 1.5;
                        velocity.y = 0;
                        onGround = true;
                        break;
                    }
                }
            }
            
            // Verificar chão normal - ALTURA SIMPLES COMO NAS PASSARELAS
            if (!onGround && player.position.y <= 2.1) {
                player.position.y = 2;
                velocity.y = 0;
                onGround = true;
            }
            
            // Removido snap forçado no segundo andar para permitir descida correta
            
            // Elevador simples: mover plataforma e jogador ao estar em cima
            if (elevators && elevators.length) {
                elevators.forEach(el => {
                    if (!el.platform || !el.platformCollider) return;
                    // Atualiza colisor para acompanhar a plataforma
                    el.platformCollider.position.y = el.platform.position.y;
                    const colliderBox = new THREE.Box3().setFromObject(el.platformCollider);
                    const playerFeetBox = new THREE.Box3(
                        new THREE.Vector3(player.position.x - 0.8, player.position.y - 1.2, player.position.z - 0.8),
                        new THREE.Vector3(player.position.x + 0.8, player.position.y, player.position.z + 0.8)
                    );
                    if (colliderBox.intersectsBox(playerFeetBox)) {
                        // velocidade de 1 m/s -> step ~ 1/60 por frame
                        const targetY = player.position.y < 7 ? 12.25 : 2.25;
                        const dy = targetY - el.platform.position.y;
                        const step = Math.sign(dy) * Math.min(Math.abs(dy), 1/60);
                        el.platform.position.y += step;
                        el.platformCollider.position.y += step;
                        player.position.y += step;
                        velocity.y = 0; // anular gravidade quando em cima
                        onGround = true;
                    }
                });
            }
            
            isOnGround = onGround;
            
            // Pulo ou sair do trem
            if (keys['Space']) {
                if (isInTrain) {
                    // Sair do trem ao pressionar SPACE
                    isInTrain = false;
                    player.position.x += 5; // Sair para o lado
                    player.position.y = 2;
                    velocity.y = 0.5; // Pequeno pulo ao sair
                } else {
                    // Pulo normal fora do trem
                    velocity.y = 0.5;
                }
            }

            // Animação de caminhada - DEPOIS do pulo
            if (moving && !isInTrain) {
                walkCycle += 0.15;
                const swing = Math.sin(walkCycle) * 0.4;
                leftArm.rotation.x = swing;
                rightArm.rotation.x = -swing;
                leftLeg.rotation.x = -swing * 0.8;
                rightLeg.rotation.x = swing * 0.8;
            } else {
                walkCycle = 0;
                leftArm.rotation.x = 0;
                rightArm.rotation.x = 0;
                leftLeg.rotation.x = 0;
                rightLeg.rotation.x = 0;
            }

            // Fogo contínuo (flame/plasma) ao manter pressionado
            if (isFiring && !showInventory && hasWeapon) {
                const wt = weapons[currentWeapon].type;
                if (wt === 'flame' || wt === 'plasma') {
                    if (!fireCooldown[wt] || fireCooldown[wt] <= 0) {
                        fireWeapon();
                        fireCooldown[wt] = wt === 'flame' ? 6 : 10; // cadência
                    } else {
                        fireCooldown[wt]--;
                    }
                }
            }

            // Atualizar portas: abrir/fechar
            if (doors && doors.length) {
                doors.forEach(d => {
                    if (!d || !d.door) return;
                    const openOffset = d.width; // desloca no eixo X
                    const targetX = d.isOpen ? d.originalX + openOffset : d.originalX;
                    const currentX = d.door.position.x;
                    const step = Math.sign(targetX - currentX) * Math.min(Math.abs(targetX - currentX), 0.2);
                    d.door.position.x += step;
                    // Auto-fechar após passar
                    if (d.isOpen && d.autoCloseTimer !== undefined) {
                        d.autoCloseTimer--;
                        if (d.autoCloseTimer <= 0) {
                            // Se o jogador já passou (z menor que a porta), fecha
                            d.isOpen = false;
                        }
                    }
                });
            }

            pickups.forEach((p, i) => {
                const d = player.position.distanceTo(p.mesh.position);
                if (d < 3) {
                    if (p.type === 'weapon') {
                        hasWeapon = true;
                        document.getElementById('weapon').textContent = 'Laser Gun';
                        score += 50;
                    } else if (p.type === 'health') {
                        health = Math.min(100, health + 30);
                    } else if (p.type === 'food') {
                        stamina = Math.min(100, stamina + 70); // Aumentada recuperação de comida para 70
                    } else if (p.type === 'energy') {
                        stamina = Math.min(100, stamina + 50); // Bateria de energia
                        health = Math.min(100, health + 10); // Pequena recuperação de vida
                        score += 25;
                    } else if (p.type === 'grenades') {
                        ammo.grenade = Math.min(5, ammo.grenade + 1);
                        updateAmmoUI();
                    } else if (p.type === 'mines') {
                        ammo.mine = Math.min(5, ammo.mine + 1);
                        updateAmmoUI();
                    } else if (p.type === 'flamethrower') {
                        ammo.flame = Math.min(5, ammo.flame + 1);
                        updateAmmoUI();
                    } else if (p.type === 'plasma_launcher') {
                        ammo.plasma = Math.min(5, ammo.plasma + 1);
                        updateAmmoUI();
                    }
                    scene.remove(p.mesh);
                    pickups.splice(i, 1);
                }
            });

            if (safeZone && player.position.distanceTo(safeZone.position) < 8) {
                level++;
                score += 100;
                isInTrain = false;
                generateWorld();
                // Reposicionar jogador na espaçonave após gerar novo mundo
                player.position.set(0, 2, 0);
            }

            const lim = 100;
            player.position.x = Math.max(-lim, Math.min(lim, player.position.x));
            player.position.z = Math.max(-lim, Math.min(lim, player.position.z));

            enemies.forEach((e, i) => {
                if (e.isDead) {
                    e.mesh.rotation.x += 0.05;
                    e.mesh.position.y -= 0.02;
                    if (e.mesh.position.y < -5) {
                        scene.remove(e.mesh);
                        enemies.splice(i, 1);
                    }
                    return;
                }

                const target = partnerHostile ? partner || player : player;
                const dir = new THREE.Vector3().subVectors(target.position || target, e.mesh.position).normalize();
                const distToPlayer = (target.position || target).distanceTo ? (target.position || target).distanceTo(e.mesh.position) : player.position.distanceTo(e.mesh.position);
                const nx = e.mesh.position.x + dir.x * e.speed;
                const nz = e.mesh.position.z + dir.z * e.speed;

                let hit = false;
                const r = 2;
                for (let b of buildings) {
                    const box = new THREE.Box3().setFromObject(b);
                    const eBox = new THREE.Box3(
                        new THREE.Vector3(nx - r, e.mesh.position.y, nz - r),
                        new THREE.Vector3(nx + r, e.mesh.position.y + 2, nz + r)
                    );
                    if (box.intersectsBox(eBox)) {
                        hit = true;
                        break;
                    }
                }

                if (!hit) {
                    e.mesh.position.x = nx;
                    e.mesh.position.z = nz;
                }

                const lookAtPos = target.position || target;
                e.mesh.rotation.y = Math.atan2(lookAtPos.x - e.mesh.position.x, lookAtPos.z - e.mesh.position.z);

                // Facehugger: pular e grudar no jogador (latch)
                if (!e.isLatched && !e.isWasp && e.health <= 3) {
                    const distP = e.mesh.position.distanceTo(player.position);
                    if (distP < 2) {
                        e.isLatched = true;
                        e.latchOffset = new THREE.Vector3(0, 1.2, 0.4);
                        e.latchTime = 0;
                    }
                }
                if (e.isLatched) {
                    const targetPos = player.position.clone().add(e.latchOffset);
                    e.mesh.position.lerp(targetPos, 0.35);
                    // Dano aumentado em 50%
                    health -= 0.75;
                    if (health <= 0) {
                        gameOver = true;
                        document.getElementById('gameOver').style.display = 'block';
                    }
                    e.latchTime++;
                    if (e.latchTime > 180) {
                        e.isLatched = false;
                    }
                }

                // Parceiro ataca inimigos
                if (partner) {
                    const target = partnerHostile ? player : e.mesh;
                    const pdir = new THREE.Vector3().subVectors(target.position || target, partner.position);
                    const pdist = pdir.length();
                    if (pdist < 25 && Math.random() < 0.02) {
                        const proj = new THREE.Mesh(
                            new THREE.SphereGeometry(0.2),
                            new THREE.MeshStandardMaterial({ color: partnerHostile ? 0xff4444 : 0x00ffff, emissive: partnerHostile ? 0xff4444 : 0x00ffff, emissiveIntensity: 1 })
                        );
                        proj.position.copy(partner.position.clone().add(new THREE.Vector3(0,1,0)));
                        pdir.normalize();
                        projectiles.push({ mesh: proj, velocity: pdir.multiplyScalar(0.8), type: 'laser', owner: 'partner' });
                        scene.add(proj);
                    }
                }

                if (distToPlayer < 3) {
                    e.biteAnimation += 0.3;
                    const head = e.mesh.children[1];
                    if (head) {
                        head.rotation.x = Math.sin(e.biteAnimation) * 0.5;
                    }

                    if (Math.sin(e.biteAnimation) > 0.9) {
                        health -= 0.5;
                        if (health <= 0) {
                            gameOver = true;
                            document.getElementById('gameOver').style.display = 'block';
                        }
                    }
                } else {
                    e.biteAnimation = 0;
                    const head = e.mesh.children[1];
                    if (head) {
                        head.rotation.x = 0;
                    }
                }

            projectiles.forEach((p, pi) => {
                if (e.mesh.position.distanceTo(p.mesh.position) < 3.5) {
                    e.health--;
                        createExplosion(p.mesh.position);
                        scene.remove(p.mesh);
                        projectiles.splice(pi, 1);

                        e.mesh.children.forEach(child => {
                            if (child.material) {
                                child.material.emissiveIntensity = 2;
                                setTimeout(() => {
                                    if (child.material) child.material.emissiveIntensity = 0.5;
                                }, 100);
                            }
                        });

                    if (e.health <= 0) {
                        e.isDead = true;
                        score += 25;
                        // Contagem de abates
                        if (p.owner === 'partner') partnerKills++; else playerKills++;
                    }
                    }
                });
            });

            projectiles.forEach((p, i) => {
                // Vida útil para partículas/efeitos
                if (p.life !== undefined) {
                    p.life--;
                    if (p.life <= 0) {
                        scene.remove(p.mesh);
                        projectiles.splice(i, 1);
                        return;
                    }
                }

                // Flame: partículas com movimento curto à frente
                if (p.type === 'flame') {
                    if (p.velocities && p.mesh.children) {
                        p.mesh.children.forEach((sphere, idx) => {
                            sphere.position.add(p.velocities[idx]);
                            sphere.material.opacity *= 0.92;
                        });
                    }
                    enemies.forEach(e => {
                        if (e.isDead) return;
                        const dist = e.mesh.position.distanceTo(p.mesh.position);
                        if (dist < 2.5) e.health -= 0.25;
                    });
                    return;
                }

                // Minas ficam paradas; explodem ao contato
                if (p.type === 'mine') {
                    enemies.forEach(e => {
                        if (e.isDead) return;
                        const dist = e.mesh.position.distanceTo(p.mesh.position);
                        if (dist < 2) {
                            createExplosion(p.mesh.position);
                            e.health -= 4;
                            scene.remove(p.mesh);
                            projectiles.splice(i, 1);
                        }
                    });
                    return;
                }

                // Movimento de projéteis comuns
                p.mesh.position.add(p.velocity);

                // Granada: gravidade e explosão ao tocar algo
                if (p.type === 'grenade') {
                    p.velocity.y -= 0.02;
                    let hit = false;
                    for (let b of buildings) {
                        if (new THREE.Box3().setFromObject(b).intersectsBox(new THREE.Box3().setFromObject(p.mesh))) {
                            hit = true; break;
                        }
                    }
                    if (p.mesh.position.y <= 1.1) hit = true;
                    if (hit) {
                        createExplosion(p.mesh.position);
                        enemies.forEach(e => {
                            const d = e.mesh.position.distanceTo(p.mesh.position);
                            if (d < 6) e.health -= 3;
                        });
                        scene.remove(p.mesh);
                        projectiles.splice(i, 1);
                        return;
                    }
                }

                // Plasma: ao colidir, splash menor
                if (p.type === 'plasma') {
                    let hit = false;
                    for (let b of buildings) {
                        if (new THREE.Box3().setFromObject(b).intersectsBox(new THREE.Box3().setFromObject(p.mesh))) { hit = true; break; }
                    }
                    if (hit) {
                        createExplosion(p.mesh.position);
                        enemies.forEach(e => {
                            const d = e.mesh.position.distanceTo(p.mesh.position);
                            if (d < 4) e.health -= 2;
                        });
                        scene.remove(p.mesh);
                        projectiles.splice(i, 1);
                        return;
                    }
                }

                // Remoção por distância
                if (p.mesh.position.length() > 200) {
                    scene.remove(p.mesh);
                    projectiles.splice(i, 1);
                }
            });

            vehicles.forEach(v => {
                const oldX = v.mesh.position.x;
                v.mesh.position.x += v.speed;
                if (Math.abs(v.mesh.position.x) > 100) v.mesh.position.x = -v.mesh.position.x;
                v.wheels.forEach(w => w.rotation.x += v.speed * 0.5);

                const carBox = new THREE.Box3().setFromObject(v.mesh);
                const playerBox = new THREE.Box3(
                    new THREE.Vector3(player.position.x - 1, player.position.y - 1, player.position.z - 1),
                    new THREE.Vector3(player.position.x + 1, player.position.y + 2, player.position.z + 1)
                );

                if (carBox.intersectsBox(playerBox) && player.position.y < 2.5 && !isInTrain) {
                    health -= 1;
                    const pushDir = new THREE.Vector3().subVectors(player.position, v.mesh.position).normalize();
                    player.position.x += pushDir.x * 2;
                    player.position.z += pushDir.z * 2;

                    v.mesh.children[0].material.emissiveIntensity = 2;
                    setTimeout(() => {
                        if (v.mesh.children[0].material) {
                            v.mesh.children[0].material.emissiveIntensity = 0.5;
                        }
                    }, 100);

                    if (health <= 0) {
                        gameOver = true;
                        document.getElementById('gameOver').style.display = 'block';
                    }
                }
            });

            // Atualizar trem
            if (train) {
                train.mesh.position.x += train.speed;
                if (Math.abs(train.mesh.position.x) > 100) train.mesh.position.x = -train.mesh.position.x;
                train.wheels.forEach(w => w.rotation.x += train.speed * 0.5);

                const trainBox = new THREE.Box3().setFromObject(train.mesh);
                const playerBox = new THREE.Box3(
                    new THREE.Vector3(player.position.x - 1, player.position.y - 1, player.position.z - 1),
                    new THREE.Vector3(player.position.x + 1, player.position.y + 2, player.position.z + 1)
                );

                if (trainBox.intersectsBox(playerBox) && !isInTrain) {
                    isInTrain = true;
                    player.position.copy(train.mesh.position);
                    player.position.y = 2;
                }
            }

            pedestrians.forEach(p => {
                p.walkCycle += 0.1;
                p.mesh.position.x += Math.sin(p.direction) * p.speed;
                p.mesh.position.z += Math.cos(p.direction) * p.speed;
                if (Math.abs(p.mesh.position.x) > 100 || Math.abs(p.mesh.position.z) > 100) {
                    p.direction = Math.random() * Math.PI * 2;
                    const sidewalkIndex = Math.floor(Math.random() * 5);
                    p.mesh.position.x = Math.random() * 80 - 40;
                    p.mesh.position.z = (sidewalkIndex - 2) * 20 + (sidewalkIndex % 2 === 0 ? 7.5 : -7.5);
                }

                if (p.isInteractive && p.mesh.children[2]) {
                    const dist = player.position.distanceTo(p.mesh.position);
                    p.mesh.children[2].visible = dist < 5;
                    if (dist < 5) {
                        p.mesh.children[2].lookAt(camera.position);
                        p.mesh.children[2].position.y = 2 + Math.sin(Date.now() * 0.002) * 0.2;
                    }
                }
            });

            if (safeZone) safeZone.rotation.y += 0.01;

            if (portal) {
                portal.rotation.y += 0.02;
                portal.rotation.z = Math.sin(Date.now() * 0.001) * 0.1;
                portal.children.forEach((child, i) => {
                    if (i < portal.children.length - 1) {
                        child.rotation.x += 0.01 * (i + 1);
                    }
                });
            }

            pickups.forEach(p => {
                p.rotation += 0.02;
                p.mesh.rotation.y = p.rotation;
                p.mesh.position.y = 0.5 + Math.sin(p.rotation * 2) * 0.3;
            });

            document.getElementById('health').textContent = Math.max(0, Math.floor(health));
            document.getElementById('stamina').textContent = Math.max(0, Math.floor(stamina));
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;

            // Atualizar câmera com base no modo
            if (cameraMode === 'first') {
                // Posicionar câmera na altura dos olhos do personagem
                camera.position.copy(player.position);
                camera.position.y += 1.6; // Altura dos olhos humanos
                
                // Aplicar rotação profissional FPS
                camera.rotation.order = 'YXZ'; // Ordem correta para FPS
                camera.rotation.y = fpsCamera.yaw;
                camera.rotation.x = fpsCamera.pitch;
                camera.rotation.z = 0;
                player.visible = false;
                
                // Mostrar arma em primeira pessoa se tiver arma
                if (hasWeapon) {
                    if (!fpsWeaponModel) {
                        fpsWeaponModel = createFPSWeapon();
                        camera.add(fpsWeaponModel);
                    }
                    // Animação de recuo ao atirar
                    if (fpsWeaponModel) {
                        fpsWeaponModel.visible = true;
                    }
                } else if (fpsWeaponModel) {
                    fpsWeaponModel.visible = false;
                }
            } else if (cameraMode === 'god') {
                camera.position.set(player.position.x, player.position.y + 20, player.position.z);
                camera.rotation.set(-Math.PI / 2, 0, 0);
                player.visible = true;
                
                // Ocultar arma FPS em outros modos
                if (fpsWeaponModel) {
                    fpsWeaponModel.visible = false;
                }
            } else {
                const d = 15, h = 8;
                const sway = Math.sin(walkCycle * 0.5) * 0.3;
                camera.position.x = player.position.x + sway;
                camera.position.y = player.position.y + h + Math.sin(walkCycle) * 0.2 + cameraOffset; // Aplicar offset para obstruções
                camera.position.z = player.position.z - d;
                camera.lookAt(player.position.x, player.position.y + 1, player.position.z);
                player.visible = true;
                
                // Ocultar arma FPS em outros modos
                if (fpsWeaponModel) {
                    fpsWeaponModel.visible = false;
                }
            }

            // Ajustar câmera para obstruções
            if (cameraMode === 'third') {
                adjustCameraForObstructions();
            }

            renderer.autoClear = false;
            renderer.clear();
            renderer.render(scene, camera);
            renderer.autoClear = true;
        }

        // Função de animação principal (sem mudanças)
        function animate() {
            requestAnimationFrame(animate);
            if (gameStarted) {
                update();
            } else {
                renderer.render(scene, camera);
            }
        }

        // Iniciar o jogo
        document.getElementById('startBtn').addEventListener('click', () => {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('customizationScreen').style.display = 'flex';
            initCustomizationPreview();
        });

        document.getElementById('confirmBtn').addEventListener('click', () => {
            document.getElementById('customizationScreen').style.display = 'none';
            
            // Remover renderer de preview com verificação de segurança
            if (previewRenderer && previewRenderer.domElement && previewRenderer.domElement.parentNode) {
                previewRenderer.domElement.parentNode.removeChild(previewRenderer.domElement);
            }
            
            gameStarted = true;
            init();
            animate();
        });
    </script>
</body>
</html>
