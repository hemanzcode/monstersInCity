<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyberpunk Survival</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            font-family: 'Courier New', monospace;
            background: #000;
        }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            font-size: 18px;
            z-index: 100;
            pointer-events: none;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #f00;
            font-size: 72px;
            text-shadow: 0 0 20px #f00;
            display: none;
            z-index: 200;
            text-align: center;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            font-size: 14px;
            text-align: center;
            z-index: 100;
            pointer-events: none;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid #0ff;
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
            box-shadow: 0 0 10px #0ff;
        }
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
            color: #0ff;
            text-shadow: 0 0 20px #0ff;
        }
        #startScreen h1 {
            font-size: 64px;
            margin-bottom: 30px;
        }
        #startBtn {
            font-size: 24px;
            padding: 15px 40px;
            background: transparent;
            border: 2px solid #0ff;
            color: #0ff;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 10px #0ff;
            transition: all 0.3s;
        }
        #startBtn:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 20px #0ff;
        }
        #customizationScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: row;
            justify-content: space-between;
            align-items: center;
            z-index: 250;
            color: #0ff;
            text-shadow: 0 0 20px #0ff;
            padding: 0 50px;
        }
        #customizationScreen h2 {
            font-size: 48px;
            margin-bottom: 20px;
        }
        .customization-left {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-right: 50px;
        }
        .customization-right {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .custom-section {
            margin: 10px 0;
            text-align: center;
        }
        .custom-section label {
            display: block;
            font-size: 20px;
            margin-bottom: 5px;
        }
        .custom-section select, .custom-section button {
            font-size: 18px;
            padding: 5px 10px;
            background: transparent;
            border: 2px solid #0ff;
            color: #0ff;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 5px #0ff;
            transition: all 0.3s;
        }
        .custom-section select:hover, .custom-section button:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 10px #0ff;
        }
        #confirmBtn {
            font-size: 24px;
            padding: 15px 40px;
            margin-top: 20px;
            background: transparent;
            border: 2px solid #0ff;
            color: #0ff;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 10px #0ff;
            transition: all 0.3s;
        }
        #confirmBtn:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 20px #0ff;
        }
        
        /* Controles Mobile */
        #mobileControls {
            display: none;
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 150;
        }
        
        /* Joystick Virtual */
        #joystickContainer {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 150px;
            height: 150px;
            pointer-events: auto;
        }
        
        #joystickBase {
            position: absolute;
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.2);
            border: 3px solid rgba(0, 255, 255, 0.5);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }
        
        #joystickStick {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.6);
            border: 2px solid #0ff;
            box-shadow: 0 0 15px #0ff;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s;
        }
        
        /* Botões de Ação */
        #actionButtons {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: auto;
        }
        
        .action-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.3);
            border: 3px solid #0ff;
            color: #0ff;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            line-height: 64px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            font-family: 'Courier New', monospace;
            user-select: none;
            touch-action: none;
        }
        
        .action-btn:active {
            background: rgba(0, 255, 255, 0.6);
            transform: scale(0.95);
        }
        
        /* Botão de Disparo Grande */
        #shootBtn {
            width: 80px;
            height: 80px;
            line-height: 74px;
            font-size: 16px;
        }
        
        /* Detectar Mobile */
        @media (max-width: 768px), (pointer: coarse) {
            #mobileControls {
                display: block;
            }
            
            #instructions {
                display: none;
            }
            
            #hud {
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1>CYBERPUNK SURVIVAL</h1>
        <p style="margin-bottom: 20px;">Encontre suprimentos e sobreviva aos monstros!</p>
        <button id="startBtn">INICIAR</button>
    </div>
    <div id="customizationScreen">
        <div class="customization-left">
            <h2>Customizar Personagem</h2>
            <div class="custom-section">
                <label for="hairSelect">Cabelo:</label>
                <select id="hairSelect">
                    <option value="none">Nenhum</option>
                    <option value="short">Curto</option>
                    <option value="long">Longo</option>
                    <option value="mohawk">Moicano</option>
                </select>
            </div>
            <div class="custom-section">
                <label for="backpackSelect">Mochila:</label>
                <select id="backpackSelect">
                    <option value="none">Nenhuma</option>
                    <option value="small">Pequena</option>
                    <option value="large">Grande</option>
                </select>
            </div>
            <div class="custom-section">
                <label for="clothesColor">Cor da Roupa:</label>
                <select id="clothesColor">
                    <option value="0x00aaff">Azul (Padrão)</option>
                    <option value="0xff0000">Vermelho</option>
                    <option value="0x00ff00">Verde</option>
                    <option value="0xffff00">Amarelo</option>
                </select>
            </div>
            <div class="custom-section">
                <label for="jacketSelect">Jaqueta:</label>
                <select id="jacketSelect">
                    <option value="none">Nenhuma</option>
                    <option value="leather">Couro</option>
                    <option value="cyber">Cyberpunk</option>
                </select>
            </div>
            <button id="confirmBtn">CONFIRMAR</button>
        </div>
        <div class="customization-right">
            <!-- Personagem será renderizado aqui -->
        </div>
    </div>
    <div id="hud">
        <div>VIDA: <span id="health">100</span></div>
        <div>STAMINA: <span id="stamina">100</span></div>
        <div>SCORE: <span id="score">0</span></div>
        <div>FASE: <span id="level">1</span></div>
        <div>ARMA: <span id="weapon">Nenhuma</span></div>
    </div>
    <div id="gameOver">
        <div>GAME OVER</div>
        <div style="font-size: 24px; margin-top: 20px;">Pressione R para reiniciar</div>
    </div>
    <div id="instructions">
        WASD: Mover | Espaço: Pular/Sair do trem | Clique: Atirar | T: Alternar visão | G: Visão aérea | ESC: Sair da primeira pessoa | Portal Azul = Próxima fase
    </div>
    <div id="crosshair"></div>
    
    <!-- Controles Mobile -->
    <div id="mobileControls">
        <!-- Joystick Virtual -->
        <div id="joystickContainer">
            <div id="joystickBase"></div>
            <div id="joystickStick"></div>
        </div>
        
        <!-- Botões de Ação -->
        <div id="actionButtons">
            <div class="action-btn" id="jumpBtn">PULAR</div>
            <div class="action-btn" id="shootBtn">ATIRAR</div>
            <div class="action-btn" id="viewBtn">VISÃO</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Variáveis globais
        let scene, camera, renderer, player;
        let enemies = [], buildings = [], vehicles = [], projectiles = [], pickups = [], pedestrians = [], sidewalks = [], roads = [], walkways = [], ramps = [], train;
        let safeZone, portal;
        let health = 100, stamina = 100, score = 0, level = 1, hasWeapon = false;
        let gameOver = false, gameStarted = false;
        let keys = {}, velocity = new THREE.Vector3();
        let isOnGround = true, walkCycle = 0;
        let leftArm, rightArm, leftLeg, rightLeg;
        let cameraMode = 'third'; // 'third', 'first', 'god'
        let worldTheme = 0;
        let isInTrain = false;
        let raycaster = new THREE.Raycaster();
        let cameraOffset = 0; // Para ajustar altura da câmera em caso de obstrução
        let fpsWeaponModel = null; // Modelo da arma para primeira pessoa
        
        // Sistema profissional de câmera primeira pessoa
        let fpsCamera = {
            yaw: 0,           // Rotação horizontal (esquerda/direita)
            pitch: 0,         // Rotação vertical (cima/baixo)
            isLocked: false,  // Se o mouse está bloqueado
            sensitivity: 0.002, // Sensibilidade do mouse
            maxPitch: Math.PI / 2 - 0.1, // Limite máximo de inclinação
            minPitch: -Math.PI / 2 + 0.1  // Limite mínimo de inclinação
        };

        // Variáveis para customização
        let previewScene, previewCamera, previewRenderer, previewPlayer;
        let customHair, customBackpack, customJacket;
        let customClothesColor = 0x00aaff;
        
        // Controles Mobile
        let mobileJoystick = {
            active: false,
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            deltaX: 0,
            deltaY: 0
        };
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // Função para atualizar a orientação da câmera FPS
        function updateFPSCamera(deltaX, deltaY) {
            if (!fpsCamera.isLocked) return;
            
            // Atualizar yaw (rotação horizontal)
            fpsCamera.yaw -= deltaX * fpsCamera.sensitivity;
            
            // Atualizar pitch (rotação vertical) com limitações
            fpsCamera.pitch -= deltaY * fpsCamera.sensitivity;
            fpsCamera.pitch = Math.max(fpsCamera.minPitch, Math.min(fpsCamera.maxPitch, fpsCamera.pitch));
        }

        // Função para calcular direção de movimento baseada na câmera FPS
        function getFPSMovementDirection() {
            const forward = new THREE.Vector3(0, 0, -1); // usar -Z como frente
            const right = new THREE.Vector3(1, 0, 0);
            
            // Aplicar rotação yaw (horizontal)
            forward.applyEuler(new THREE.Euler(0, fpsCamera.yaw, 0));
            right.applyEuler(new THREE.Euler(0, fpsCamera.yaw, 0));
            
            return { forward, right };
        }

        // Função para solicitar bloqueio do ponteiro
        function requestPointerLock() {
            if (cameraMode === 'first' && !fpsCamera.isLocked) {
                document.body.requestPointerLock();
            }
        }

        // Função para liberar bloqueio do ponteiro
        function exitPointerLock() {
            if (fpsCamera.isLocked) {
                document.exitPointerLock();
            }
        }

        // Função para criar o jogador (agora com opções de customização)
        function createPlayer(customOptions = {}) {
            const group = new THREE.Object3D();
            const bodyMat = new THREE.MeshStandardMaterial({ color: customOptions.clothesColor || 0x00aaff, emissive: 0x003366, emissiveIntensity: 0.44 }); // Aumentado de 0.2 para 0.44 (120% mais brilho)

            const body = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.2, 0.4), bodyMat);
            body.position.y = 0.6;
            group.add(body);

            const head = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), new THREE.MeshStandardMaterial({ color: 0xffcc99 }));
            head.position.y = 1.5;
            group.add(head);

            leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.8, 0.25), bodyMat);
            leftArm.position.set(-0.55, 0.6, 0);
            group.add(leftArm);

            rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.8, 0.25), bodyMat);
            rightArm.position.set(0.55, 0.6, 0);
            group.add(rightArm);

            const legMat = new THREE.MeshStandardMaterial({ color: 0x003366 });
            leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.9, 0.3), legMat);
            leftLeg.position.set(-0.25, -0.45, 0);
            group.add(leftLeg);

            rightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.9, 0.3), legMat);
            rightLeg.position.set(0.25, -0.45, 0);
            group.add(rightLeg);

            // Adicionar customizações
            if (customOptions.hair) {
                let hairGeom, hairMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
                if (customOptions.hair === 'short') {
                    hairGeom = new THREE.BoxGeometry(0.65, 0.2, 0.65);
                } else if (customOptions.hair === 'long') {
                    hairGeom = new THREE.BoxGeometry(0.65, 0.5, 0.65);
                } else if (customOptions.hair === 'mohawk') {
                    hairGeom = new THREE.BoxGeometry(0.2, 0.4, 0.65);
                }
                customHair = new THREE.Mesh(hairGeom, hairMat);
                customHair.position.set(0, 1.8 + (customOptions.hair === 'long' ? 0.15 : 0), 0);
                group.add(customHair);
            }

            if (customOptions.backpack) {
                let backpackGeom, backpackMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
                if (customOptions.backpack === 'small') {
                    backpackGeom = new THREE.BoxGeometry(0.7, 0.8, 0.5);
                } else if (customOptions.backpack === 'large') {
                    backpackGeom = new THREE.BoxGeometry(0.9, 1.0, 0.6);
                }
                customBackpack = new THREE.Mesh(backpackGeom, backpackMat);
                customBackpack.position.set(0, 0.6, -0.45);
                group.add(customBackpack);
            }

            if (customOptions.jacket) {
                let jacketGeom, jacketMat = new THREE.MeshStandardMaterial({ color: customOptions.jacket === 'leather' ? 0x4a2700 : 0x00ffff });
                jacketGeom = new THREE.BoxGeometry(0.9, 1.3, 0.5);
                customJacket = new THREE.Mesh(jacketGeom, jacketMat);
                customJacket.position.set(0, 0.6, 0);
                group.add(customJacket);
            }

            return group;
        }

        // Função para inicializar a cena de preview de customização
        function initCustomizationPreview() {
            previewScene = new THREE.Scene();
            previewScene.background = new THREE.Color(0x000000);
            previewScene.fog = new THREE.FogExp2(0x000000, 0.1);

            // Calcular tamanho da área direita (metade da tela)
            const rightAreaWidth = window.innerWidth / 2;
            const rightAreaHeight = window.innerHeight;

            previewCamera = new THREE.PerspectiveCamera(75, rightAreaWidth / rightAreaHeight, 0.1, 1000);
            previewRenderer = new THREE.WebGLRenderer({ antialias: true });
            previewRenderer.setSize(rightAreaWidth, rightAreaHeight);
            
            // Adicionar o renderer à área direita
            const rightArea = document.querySelector('.customization-right');
            if (rightArea) {
                rightArea.appendChild(previewRenderer.domElement);
            } else {
                // Fallback: adicionar ao body se a área direita não for encontrada
                document.body.appendChild(previewRenderer.domElement);
                console.log('Área direita não encontrada, usando fallback');
            }

            // Aumentar brilho com mais luzes
            previewScene.add(new THREE.AmbientLight(0xffffff, 1.2)); // Aumentado de 0.5 para 1.2
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.6); // Aumentado de 0.8 para 1.6
            dirLight.position.set(5, 10, 5);
            previewScene.add(dirLight);
            
            // Adicionar luz adicional para mais brilho
            const extraLight = new THREE.DirectionalLight(0xffffff, 0.8);
            extraLight.position.set(-5, 10, -5);
            previewScene.add(extraLight);

            previewCamera.position.set(0, 2, 5);
            previewCamera.lookAt(0, 1.5, 0);

            // Aguardar um frame antes de criar o player para garantir que os elementos HTML estejam prontos
            setTimeout(() => {
                updatePreviewPlayer();
            }, 100);

            function animatePreview() {
                requestAnimationFrame(animatePreview);
                if (previewPlayer) {
                    previewPlayer.rotation.y += 0.01;
                }
                previewRenderer.render(previewScene, previewCamera);
            }
            animatePreview();

            window.addEventListener('resize', () => {
                const newRightAreaWidth = window.innerWidth / 2;
                const newRightAreaHeight = window.innerHeight;
                previewCamera.aspect = newRightAreaWidth / newRightAreaHeight;
                previewCamera.updateProjectionMatrix();
                previewRenderer.setSize(newRightAreaWidth, newRightAreaHeight);
            });
        }

        // Função para atualizar o player de preview com as opções selecionadas
        function updatePreviewPlayer() {
            if (previewPlayer) previewScene.remove(previewPlayer);

            // Verificar se os elementos HTML existem antes de acessá-los
            const hairSelect = document.getElementById('hairSelect');
            const backpackSelect = document.getElementById('backpackSelect');
            const clothesColorSelect = document.getElementById('clothesColor');
            const jacketSelect = document.getElementById('jacketSelect');

            if (!hairSelect || !backpackSelect || !clothesColorSelect || !jacketSelect) {
                console.log('Elementos HTML ainda não estão prontos, aguardando...');
                return;
            }

            const hair = hairSelect.value;
            const backpack = backpackSelect.value;
            const clothesColor = parseInt(clothesColorSelect.value);
            const jacket = jacketSelect.value;

            previewPlayer = createPlayer({ hair, backpack, clothesColor, jacket });
            previewPlayer.position.set(0, 0, 0);
            previewScene.add(previewPlayer);
        }

        // Função para aplicar customizações ao player do jogo
        function applyCustomizations() {
            const hair = document.getElementById('hairSelect').value;
            const backpack = document.getElementById('backpackSelect').value;
            customClothesColor = parseInt(document.getElementById('clothesColor').value);
            const jacket = document.getElementById('jacketSelect').value;

            player = createPlayer({ hair, backpack, clothesColor: customClothesColor, jacket });
            // Spawn em uma calçada segura (fora das passarelas)
            player.position.set(15, 2, 27.5); // Calçada lateral segura
            scene.add(player);
        }

        // Adicionar event listeners para atualizar preview em tempo real
        document.getElementById('hairSelect').addEventListener('change', updatePreviewPlayer);
        document.getElementById('backpackSelect').addEventListener('change', updatePreviewPlayer);
        document.getElementById('clothesColor').addEventListener('change', updatePreviewPlayer);
        document.getElementById('jacketSelect').addEventListener('change', updatePreviewPlayer);

        // Função para criar o dinossauro (sem mudanças)
        function createDino() {
            const group = new THREE.Object3D();
            const mat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.5 });

            const body = new THREE.Mesh(new THREE.BoxGeometry(3, 2.25, 1.5), mat);
            body.position.y = 1.125;
            group.add(body);

            const head = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 1.8), mat);
            head.position.set(0, 1.5, 1.8);
            group.add(head);

            const tail = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 3), mat);
            tail.position.set(0, 1.05, -2.25);
            tail.rotation.x = -0.3;
            group.add(tail);

            const leg1 = new THREE.Mesh(new THREE.BoxGeometry(0.45, 1.5, 0.45), mat);
            leg1.position.set(-0.9, 0, -0.75);
            group.add(leg1);

            const leg2 = new THREE.Mesh(new THREE.BoxGeometry(0.45, 1.5, 0.45), mat);
            leg2.position.set(0.9, 0, -0.75);
            group.add(leg2);

            const eyeMat = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 1 });
            const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.22), eyeMat);
            eye1.position.set(-0.375, 1.8, 2.55);
            group.add(eye1);

            const eye2 = new THREE.Mesh(new THREE.SphereGeometry(0.22), eyeMat);
            eye2.position.set(0.375, 1.8, 2.55);
            group.add(eye2);

            return group;
        }

        // Função para criar rótulos (sem mudanças)
        function createLabel(text, color, scale = 5) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;
            ctx.fillStyle = color;
            ctx.font = 'bold 60px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(text, 256, 64);

            const texture = new THREE.CanvasTexture(canvas);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture, transparent: true }));
            sprite.scale.set(scale, scale / 4, 1);
            return sprite;
        }

        // Função para criar mão com arma para primeira pessoa
        function createFPSWeapon() {
            const group = new THREE.Object3D();
            
            // Mão direita
            const handMat = new THREE.MeshStandardMaterial({ color: 0xffcc99 });
            const hand = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.3), handMat);
            hand.position.set(0, 0, 0);
            group.add(hand);
            
            // Braço
            const arm = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.12, 0.4), handMat);
            arm.position.set(0, 0, -0.35);
            group.add(arm);
            
            // Bazuca verde
            const weaponMat = new THREE.MeshStandardMaterial({ 
                color: 0x00ff00, 
                emissive: 0x00ff00, 
                emissiveIntensity: 0.5 
            });
            
            // Corpo da bazuca
            const weaponBody = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.8), weaponMat);
            weaponBody.position.set(0, -0.05, 0.4);
            group.add(weaponBody);
            
            // Gatilho
            const trigger = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.08, 0.05), new THREE.MeshStandardMaterial({ color: 0x333333 }));
            trigger.position.set(0, -0.12, 0.1);
            group.add(trigger);
            
            // Bico da bazuca
            const nozzle = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.18, 0.15), weaponMat);
            nozzle.position.set(0, -0.05, 0.85);
            group.add(nozzle);
            
            // Posicionar no canto inferior direito da tela
            group.position.set(0.3, -0.25, -0.5);
            group.rotation.y = -0.1;
            
            return group;
        }

        // Função para criar pedestre (sem mudanças)
        function createPedestrian(isInteractive = false) {
            const group = new THREE.Object3D();
            const colors = [0xff00ff, 0x00ffff, 0xffff00, 0xff0088, 0x00ff88];
            const color = colors[Math.floor(Math.random() * colors.length)];
            const bodyMat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.3 });

            const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1, 0.3), bodyMat);
            body.position.y = 0.5;
            group.add(body);

            const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), new THREE.MeshStandardMaterial({ color: 0xffcc99 }));
            head.position.y = 1.2;
            group.add(head);

            if (isInteractive) {
                const label = createLabel('Portal está a ' + (Math.random() > 0.5 ? 'norte' : 'sul'), '#ffffff', 6); // Aumentado scale para 6
                label.position.y = 2;
                label.visible = false;
                group.add(label);
            }

            return group;
        }

        // Função para criar cruz vermelha (medicamento) (sem mudanças)
        function createRedCross() {
            const group = new THREE.Object3D();
            const mat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.9 });

            const vertical = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.6, 0.4), mat);
            vertical.position.y = 0.8;
            group.add(vertical);

            const horizontal = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.4, 0.4), mat);
            horizontal.position.y = 0.8;
            group.add(horizontal);

            return group;
        }

        // Função para criar trem (sem mudanças)
        function createTrain() {
            const group = new THREE.Object3D();
            const mat = new THREE.MeshStandardMaterial({ color: 0x333333, emissive: 0x00ffff, emissiveIntensity: 0.5 });

            const body = new THREE.Mesh(new THREE.BoxGeometry(10, 3, 4), mat);
            body.position.y = 1.5;
            group.add(body);

            const wheels = [];
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
            const wheelGeom = new THREE.CylinderGeometry(0.6, 0.6, 0.4, 16);

            for (let i = -1; i <= 1; i += 2) {
                for (let j = -1; j <= 1; j += 2) {
                    const wheel = new THREE.Mesh(wheelGeom, wheelMat);
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(i * 3, 0.3, j * 2);
                    group.add(wheel);
                    wheels.push(wheel);
                }
            }

            return { mesh: group, wheels, speed: 0.3, axis: 'x' };
        }

        // Função para criar explosão (sem mudanças)
        function createExplosion(position) {
            const explosionGroup = new THREE.Object3D();

            for (let i = 0; i < 8; i++) {
                const size = Math.random() * 1.5 + 0.5;
                const sphere = new THREE.Mesh(
                    new THREE.SphereGeometry(size, 8, 8),
                    new THREE.MeshStandardMaterial({
                        color: Math.random() > 0.5 ? 0xff6600 : 0xffff00,
                        emissive: Math.random() > 0.5 ? 0xff6600 : 0xffff00,
                        emissiveIntensity: 2,
                        transparent: true,
                        opacity: 1
                    })
                );
                sphere.position.set(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                );
                explosionGroup.add(sphere);
            }

            explosionGroup.position.copy(position);
            scene.add(explosionGroup);

            let scale = 1;
            const interval = setInterval(() => {
                scale += 0.3;
                explosionGroup.scale.set(scale, scale, scale);
                explosionGroup.children.forEach(child => {
                    child.material.opacity -= 0.1;
                });

                if (scale > 4) {
                    clearInterval(interval);
                    scene.remove(explosionGroup);
                }
            }, 50);
        }

        // Função para inicializar a cena do jogo (sem mudanças significativas)
        function init() {
            scene = new THREE.Scene();
            updateWorldTheme();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0x0a0a2e, 0.3));
            const light = new THREE.DirectionalLight(0x00ffff, 0.5);
            light.position.set(50, 100, 50);
            scene.add(light);

            applyCustomizations(); // Aplicar customizações ao player

            generateWorld();

            document.addEventListener('keydown', e => {
                keys[e.code] = true;
                if (e.code === 'KeyR' && gameOver) location.reload();
                if (e.code === 'KeyT' && !gameOver && gameStarted) {
                    const previousMode = cameraMode;
                    cameraMode = cameraMode === 'first' ? 'third' : 'first';
                    
                    // Gerenciar bloqueio do ponteiro ao alternar modos
                    if (previousMode === 'first' && cameraMode !== 'first') {
                        exitPointerLock();
                    } else if (cameraMode === 'first') {
                        // Resetar orientação da câmera FPS ao entrar no modo
                        fpsCamera.yaw = player.rotation.y;
                        fpsCamera.pitch = 0;
                    }
                }
                if (e.code === 'KeyG' && !gameOver && gameStarted) {
                    cameraMode = cameraMode === 'god' ? 'third' : 'god';
                }
                if (e.code === 'Space') {
                    e.preventDefault(); // impedir comportamento padrão SEMPRE
                }
            });
            document.addEventListener('keyup', e => {
                keys[e.code] = false;
                if (e.code === 'Space') { e.preventDefault(); }
            });
            document.addEventListener('click', () => {
                if (!hasWeapon || gameOver || !gameStarted) return;
                const proj = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3),
                    new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 1 })
                );
                
                // Ajustar origem do tiro baseado no modo de câmera
                if (cameraMode === 'first') {
                    // Tiro sai da câmera em primeira pessoa
                    proj.position.copy(camera.position);
                    
                    // Direção baseada na rotação da câmera FPS
                    const dir = new THREE.Vector3(0, 0, -1);
                    dir.applyEuler(new THREE.Euler(fpsCamera.pitch, fpsCamera.yaw, 0, 'YXZ'));
                    
                    projectiles.push({ mesh: proj, velocity: dir.multiplyScalar(0.8) });
                    
                    // Animação de recuo da arma
                    if (fpsWeaponModel) {
                        const originalZ = fpsWeaponModel.position.z;
                        fpsWeaponModel.position.z -= 0.1;
                        setTimeout(() => {
                            if (fpsWeaponModel) fpsWeaponModel.position.z = originalZ;
                        }, 50);
                    }
                } else {
                    // Tiro sai do jogador em terceira pessoa
                    proj.position.copy(player.position);
                    proj.position.y += 1;
                    const dir = new THREE.Vector3(
                        Math.sin(player.rotation.y),
                        0,
                        Math.cos(player.rotation.y)
                    );
                    projectiles.push({ mesh: proj, velocity: dir.multiplyScalar(0.8) });
                }
                
                scene.add(proj);
            });

            // Sistema profissional de controle de mouse para primeira pessoa
            document.addEventListener('mousemove', (e) => {
                if (cameraMode === 'first' && fpsCamera.isLocked) {
                    updateFPSCamera(e.movementX, e.movementY);
                }
            });

            // Solicitar bloqueio de ponteiro para primeira pessoa
            document.addEventListener('click', () => {
                requestPointerLock();
            });

            // Gerenciar mudanças no bloqueio do ponteiro
            document.addEventListener('pointerlockchange', () => {
                fpsCamera.isLocked = document.pointerLockElement === document.body;
                
                // Se sair da primeira pessoa, liberar o bloqueio
                if (cameraMode !== 'first') {
                    exitPointerLock();
                }
            });

            // Liberar bloqueio ao pressionar ESC
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Escape' && fpsCamera.isLocked) {
                    exitPointerLock();
                }
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Inicializar controles mobile
            if (isMobile) {
                initMobileControls();
            }
        }
        
        // Funções de controle mobile
        function initMobileControls() {
            const joystickContainer = document.getElementById('joystickContainer');
            const joystickStick = document.getElementById('joystickStick');
            const jumpBtn = document.getElementById('jumpBtn');
            const shootBtn = document.getElementById('shootBtn');
            const viewBtn = document.getElementById('viewBtn');
            
            // Joystick touch events
            joystickContainer.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = joystickContainer.getBoundingClientRect();
                mobileJoystick.active = true;
                mobileJoystick.startX = rect.left + rect.width / 2;
                mobileJoystick.startY = rect.top + rect.height / 2;
                mobileJoystick.currentX = touch.clientX;
                mobileJoystick.currentY = touch.clientY;
                updateJoystickPosition();
            });
            
            joystickContainer.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!mobileJoystick.active) return;
                const touch = e.touches[0];
                mobileJoystick.currentX = touch.clientX;
                mobileJoystick.currentY = touch.clientY;
                updateJoystickPosition();
            });
            
            joystickContainer.addEventListener('touchend', (e) => {
                e.preventDefault();
                mobileJoystick.active = false;
                mobileJoystick.deltaX = 0;
                mobileJoystick.deltaY = 0;
                joystickStick.style.transform = 'translate(-50%, -50%)';
                // Resetar teclas de movimento
                keys['KeyW'] = false;
                keys['KeyA'] = false;
                keys['KeyS'] = false;
                keys['KeyD'] = false;
            });
            
            // Botão de pulo
            jumpBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys['Space'] = true;
            });
            
            jumpBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys['Space'] = false;
            });
            
            // Botão de atirar
            shootBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (!hasWeapon || gameOver || !gameStarted) return;
                
                // Simular clique para atirar
                const clickEvent = new MouseEvent('click', {
                    view: window,
                    bubbles: true,
                    cancelable: true
                });
                document.dispatchEvent(clickEvent);
            });
            
            // Botão de alternar visão
            viewBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameOver || !gameStarted) return;
                
                const previousMode = cameraMode;
                cameraMode = cameraMode === 'first' ? 'third' : 'first';
                
                if (previousMode === 'first' && cameraMode !== 'first') {
                    exitPointerLock();
                } else if (cameraMode === 'first') {
                    fpsCamera.yaw = player.rotation.y;
                    fpsCamera.pitch = 0;
                }
            });
        }
        
        function updateJoystickPosition() {
            const joystickStick = document.getElementById('joystickStick');
            
            // Calcular delta
            const deltaX = mobileJoystick.currentX - mobileJoystick.startX;
            const deltaY = mobileJoystick.currentY - mobileJoystick.startY;
            
            // Limitar distância máxima do joystick
            const maxDistance = 45;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            if (distance > maxDistance) {
                const angle = Math.atan2(deltaY, deltaX);
                mobileJoystick.deltaX = Math.cos(angle) * maxDistance;
                mobileJoystick.deltaY = Math.sin(angle) * maxDistance;
            } else {
                mobileJoystick.deltaX = deltaX;
                mobileJoystick.deltaY = deltaY;
            }
            
            // Atualizar posição visual do stick
            joystickStick.style.transform = `translate(calc(-50% + ${mobileJoystick.deltaX}px), calc(-50% + ${mobileJoystick.deltaY}px))`;
            
            // Mapear para teclas WASD (normalizado)
            const threshold = 10;
            keys['KeyW'] = mobileJoystick.deltaY < -threshold;
            keys['KeyS'] = mobileJoystick.deltaY > threshold;
            keys['KeyA'] = mobileJoystick.deltaX < -threshold;
            keys['KeyD'] = mobileJoystick.deltaX > threshold;
        }

        // Função para atualizar o tema do mundo (sem mudanças)
        function updateWorldTheme() {
            const themes = [
                { name: 'Noite', fog: 0x000a1f, ambient: 0x0a0a2e, ground: 0x0a0a1f, sidewalk: 0x333333 },
                { name: 'Manhã', fog: 0x87ceeb, ambient: 0xffffff, ground: 0x3a3a3a, sidewalk: 0x666666 },
                { name: 'Tarde', fog: 0xffa500, ambient: 0xffcc88, ground: 0x4a4a4a, sidewalk: 0x777777 },
                { name: 'Pôr do Sol', fog: 0xff6347, ambient: 0xff8866, ground: 0x2a2a2a, sidewalk: 0x555555 }
            ];

            const theme = themes[worldTheme % themes.length];
            scene.fog = new THREE.FogExp2(theme.fog, 0.008);

            scene.children.forEach(child => {
                if (child instanceof THREE.AmbientLight) {
                    child.color.setHex(theme.ambient);
                    child.intensity = worldTheme === 0 ? 0.3 : 0.6;
                }
            });
        }

        // Função para gerar o mundo (sem mudanças)
        function generateWorld() {
            buildings.forEach(b => scene.remove(b));
            enemies.forEach(e => scene.remove(e.mesh));
            vehicles.forEach(v => scene.remove(v.mesh));
            pickups.forEach(p => scene.remove(p.mesh));
            pedestrians.forEach(p => scene.remove(p.mesh));
            sidewalks.forEach(s => scene.remove(s));
            roads.forEach(r => scene.remove(r));
            walkways.forEach(w => scene.remove(w));
            ramps.forEach(r => scene.remove(r));
            if (train) scene.remove(train.mesh);
            if (safeZone) scene.remove(safeZone);
            if (portal) scene.remove(portal);

            buildings = [];
            enemies = [];
            vehicles = [];
            pickups = [];
            pedestrians = [];
            sidewalks = [];
            roads = [];
            walkways = [];
            ramps = [];
            train = null;

            worldTheme++;
            updateWorldTheme();

            const themes = [
                { ground: 0x0a0a1f, sidewalk: 0x333333 },
                { ground: 0x3a3a3a, sidewalk: 0x666666 },
                { ground: 0x4a4a4a, sidewalk: 0x777777 },
                { ground: 0x2a2a2a, sidewalk: 0x555555 }
            ];
            const currentTheme = themes[worldTheme % themes.length];

            // Chão base
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(500, 500),
                new THREE.MeshStandardMaterial({ color: currentTheme.ground })
            );
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);

            // Pistas para carros
            for (let i = -2; i <= 2; i++) {
                const road = new THREE.Mesh(
                    new THREE.PlaneGeometry(500, 10),
                    new THREE.MeshStandardMaterial({ color: 0x1c2526 })
                );
                road.rotation.x = -Math.PI / 2;
                road.position.set(0, 0.01, i * 20);
                roads.push(road);
                scene.add(road);
            }

            // Calçadas
            for (let i = -2; i <= 2; i++) {
                const sidewalk1 = new THREE.Mesh(
                    new THREE.BoxGeometry(500, 0.2, 5),
                    new THREE.MeshStandardMaterial({ color: currentTheme.sidewalk })
                );
                sidewalk1.position.set(0, 0.1, i * 20 + 7.5);
                sidewalks.push(sidewalk1);
                scene.add(sidewalk1);

                const sidewalk2 = new THREE.Mesh(
                    new THREE.BoxGeometry(500, 0.2, 5),
                    new THREE.MeshStandardMaterial({ color: currentTheme.sidewalk })
                );
                sidewalk2.position.set(0, 0.1, i * 20 - 7.5);
                sidewalks.push(sidewalk2);
                scene.add(sidewalk2);
            }

            // Passarelas com rampas
            for (let i = -1; i <= 1; i++) {
                const walkway = new THREE.Mesh(
                    new THREE.BoxGeometry(10, 0.3, 20),
                    new THREE.MeshStandardMaterial({ color: 0x555555 })
                );
                walkway.position.set(i * 20, 3, 0);
                walkways.push(walkway);
                scene.add(walkway);

                // Suportes da passarela
                const support1 = new THREE.Mesh(
                    new THREE.BoxGeometry(0.5, 3, 0.5),
                    new THREE.MeshStandardMaterial({ color: 0x333333 })
                );
                support1.position.set(i * 20 - 5, 1.5, -10);
                scene.add(support1);

                const support2 = new THREE.Mesh(
                    new THREE.BoxGeometry(0.5, 3, 0.5),
                    new THREE.MeshStandardMaterial({ color: 0x333333 })
                );
                support2.position.set(i * 20 + 5, 1.5, -10);
                scene.add(support2);

                const support3 = new THREE.Mesh(
                    new THREE.BoxGeometry(0.5, 3, 0.5),
                    new THREE.MeshStandardMaterial({ color: 0x333333 })
                );
                support3.position.set(i * 20 - 5, 1.5, 10);
                scene.add(support3);

                const support4 = new THREE.Mesh(
                    new THREE.BoxGeometry(0.5, 3, 0.5),
                    new THREE.MeshStandardMaterial({ color: 0x333333 })
                );
                support4.position.set(i * 20 + 5, 1.5, 10);
                scene.add(support4);

                // Rampas
                const ramp1 = new THREE.Mesh(
                    new THREE.BoxGeometry(10, 0.3, 5),
                    new THREE.MeshStandardMaterial({ color: 0x555555 })
                );
                ramp1.position.set(i * 20, 1.5, 12.5);
                ramp1.rotation.x = Math.PI / 6;
                ramps.push(ramp1);
                scene.add(ramp1);

                const ramp2 = new THREE.Mesh(
                    new THREE.BoxGeometry(10, 0.3, 5),
                    new THREE.MeshStandardMaterial({ color: 0x555555 })
                );
                ramp2.position.set(i * 20, 1.5, -12.5);
                ramp2.rotation.x = -Math.PI / 6;
                ramps.push(ramp2);
                scene.add(ramp2);
            }

            // Trem
            train = createTrain();
            train.mesh.position.set(-50, 0, 50);
            scene.add(train.mesh);

            for (let i = 0; i < 30; i++) {
                const h = Math.random() * 30 + 10;
                const w = Math.random() * 8 + 5;
                const d = Math.random() * 8 + 5;
                const building = new THREE.Mesh(
                    new THREE.BoxGeometry(w, h, d),
                    new THREE.MeshStandardMaterial({
                        color: Math.random() > 0.5 ? 0x1a1a3e : 0x2e1a3e,
                        emissive: Math.random() > 0.7 ? 0x00ffff : 0xff00ff,
                        emissiveIntensity: 0.2
                    })
                );
                const a = Math.random() * Math.PI * 2;
                const dist = Math.random() * 80 + 30;
                building.position.set(Math.cos(a) * dist, h / 2, Math.sin(a) * dist);
                buildings.push(building);
                scene.add(building);
            }

            for (let i = 0; i < 10; i++) {
                const carGroup = new THREE.Object3D();
                const car = new THREE.Mesh(
                    new THREE.BoxGeometry(6, 3, 3),
                    new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff, emissive: 0x00ffff, emissiveIntensity: 0.5 })
                );
                car.position.y = 0.75;
                carGroup.add(car);

                const wheelMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
                const wheelGeom = new THREE.CylinderGeometry(0.6, 0.6, 0.4, 16);

                const wheel1 = new THREE.Mesh(wheelGeom, wheelMat);
                wheel1.rotation.z = Math.PI / 2;
                wheel1.position.set(-2.2, -0.15, 1.8);
                carGroup.add(wheel1);

                const wheel2 = new THREE.Mesh(wheelGeom, wheelMat);
                wheel2.rotation.z = Math.PI / 2;
                wheel2.position.set(-2.2, -0.15, -1.8);
                carGroup.add(wheel2);

                const wheel3 = new THREE.Mesh(wheelGeom, wheelMat);
                wheel3.rotation.z = Math.PI / 2;
                wheel3.position.set(2.2, -0.15, 1.8);
                carGroup.add(wheel3);

                const wheel4 = new THREE.Mesh(wheelGeom, wheelMat);
                wheel4.rotation.z = Math.PI / 2;
                wheel4.position.set(2.2, -0.15, -1.8);
                carGroup.add(wheel4);

                carGroup.position.set(Math.random() * 100 - 50, 0, (Math.floor(Math.random() * 5) - 2) * 20);
                vehicles.push({
                    mesh: carGroup,
                    wheels: [wheel1, wheel2, wheel3, wheel4],
                    speed: (Math.random() * 0.25 + 0.15) * (Math.random() > 0.5 ? 1 : -1),
                    axis: 'x'
                });
                scene.add(carGroup);
            }

            for (let i = 0; i < 3 + level * 2; i++) {
                const dino = createDino();
                const a = Math.random() * Math.PI * 2;
                const dist = Math.random() * 40 + 20;
                dino.position.set(Math.cos(a) * dist, 0, Math.sin(a) * dist);
                enemies.push({
                    mesh: dino,
                    speed: 0.05 + level * 0.01,
                    health: 5,
                    biteAnimation: 0,
                    isDead: false
                });
                scene.add(dino);
            }

            for (let i = 0; i < 15; i++) {
                const isInteractive = Math.random() > 0.7;
                const ped = createPedestrian(isInteractive);
                const sidewalkIndex = Math.floor(Math.random() * 5);
                ped.position.set(
                    Math.random() * 80 - 40,
                    0.2,
                    (sidewalkIndex - 2) * 20 + (sidewalkIndex % 2 === 0 ? 7.5 : -7.5)
                );
                const walkDir = Math.random() * Math.PI * 2;
                pedestrians.push({
                    mesh: ped,
                    direction: walkDir,
                    speed: 0.03 + Math.random() * 0.02,
                    walkCycle: Math.random() * 10,
                    isInteractive
                });
                scene.add(ped);
            }

            // Aumentar número de pickups de comida para 8 (mais caixas de comida)
            for (let i = 0; i < 8; i++) {
                const type = Math.random();
                let pickup;
                let label;
                if (type > 0.7) {
                    pickup = new THREE.Mesh(
                        new THREE.BoxGeometry(1, 1, 1),
                        new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 0.9 })
                    );
                    label = createLabel('ARMA', '#ffff00');
                    pickup.type = 'weapon';
                } else if (type > 0.3) {
                    pickup = createRedCross();
                    label = createLabel('MEDICAMENTO', '#ff0000');
                    pickup.type = 'health';
                } else {
                    pickup = new THREE.Mesh(
                        new THREE.BoxGeometry(1, 1, 1),
                        new THREE.MeshStandardMaterial({ color: 0xffa500, emissive: 0xffa500, emissiveIntensity: 0.9 })
                    );
                    label = createLabel('COMIDA', '#ffa500');
                    pickup.type = 'food';
                }
                pickup.position.set(Math.random() * 60 - 30, 0.5, Math.random() * 60 - 30);
                label.position.y = 2.5;
                pickup.add(label);
                pickups.push({ mesh: pickup, type: pickup.type, rotation: 0 });
                scene.add(pickup);
            }

            safeZone = new THREE.Mesh(
                new THREE.BoxGeometry(8, 8, 8),
                new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 0.5, transparent: true, opacity: 0.6 })
            );
            const sa = Math.random() * Math.PI * 2;
            const sd = Math.random() * 50 + 40;
            safeZone.position.set(Math.cos(sa) * sd, 4, Math.sin(sa) * sd);
            scene.add(safeZone);

            portal = new THREE.Object3D();
            const portalRings = 5;
            for (let i = 0; i < portalRings; i++) {
                const ring = new THREE.Mesh(
                    new THREE.TorusGeometry(3 - i * 0.4, 0.15, 16, 32),
                    new THREE.MeshStandardMaterial({
                        color: 0x00ffff,
                        emissive: 0x00ffff,
                        emissiveIntensity: 1,
                        transparent: true,
                        opacity: 0.7 - i * 0.1
                    })
                );
                ring.rotation.y = (i * Math.PI) / portalRings;
                portal.add(ring);
            }

            const core = new THREE.Mesh(
                new THREE.SphereGeometry(1.5, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0x00ffff,
                    emissive: 0x00ffff,
                    emissiveIntensity: 1.5,
                    transparent: true,
                    opacity: 0.5
                })
            );
            portal.add(core);

            const exitLabel = createLabel('SAIDA', '#00ffff', 8);
            exitLabel.position.y = 5;
            portal.add(exitLabel);

            portal.position.copy(safeZone.position);
            portal.position.y = 4;
            scene.add(portal);
        }

        // Função para verificar colisão (sem mudanças)
        function checkCollision(x, z, y = player.position.y) {
            const r = 1.5;
            for (let b of buildings) {
                const box = new THREE.Box3().setFromObject(b);
                const pBox = new THREE.Box3(
                    new THREE.Vector3(x - r, y - 1, z - r),
                    new THREE.Vector3(x + r, y + 2, z + r)
                );
                if (box.intersectsBox(pBox)) return true;
            }
            for (let v of vehicles) {
                const box = new THREE.Box3().setFromObject(v.mesh);
                const pBox = new THREE.Box3(
                    new THREE.Vector3(x - r, y - 1, z - r),
                    new THREE.Vector3(x + r, y + 2, z + r)
                );
                if (box.intersectsBox(pBox)) return true;
            }
            for (let w of walkways) {
                const box = new THREE.Box3().setFromObject(w);
                const pBox = new THREE.Box3(
                    new THREE.Vector3(x - r, y - 1, z - r),
                    new THREE.Vector3(x + r, y + 2, z + r)
                );
                if (box.intersectsBox(pBox)) {
                    player.position.y = w.position.y + 1.5;
                    return false;
                }
            }
            for (let r of ramps) {
                const box = new THREE.Box3().setFromObject(r);
                const pBox = new THREE.Box3(
                    new THREE.Vector3(x - r, y - 1, z - r),
                    new THREE.Vector3(x + r, y + 2, z + r)
                );
                if (box.intersectsBox(pBox)) {
                    player.position.y = r.position.y + 1.5;
                    return false;
                }
            }
            return false;
        }

        // Função para ajustar câmera para evitar obstruções (sem mudanças)
        function adjustCameraForObstructions() {
            if (cameraMode !== 'third') return;

            const playerHead = new THREE.Vector3(player.position.x, player.position.y + 1, player.position.z);
            const cameraPos = camera.position.clone();

            raycaster.set(cameraPos, playerHead.clone().sub(cameraPos).normalize());
            const intersects = raycaster.intersectObjects(buildings, true);

            if (intersects.length > 0) {
                // Se houver obstrução, elevar a câmera
                cameraOffset = Math.min(cameraOffset + 0.5, 10); // Limite de elevação
                camera.position.y += 0.5;
            } else {
                cameraOffset = Math.max(cameraOffset - 0.3, 0); // Reduzir elevação gradualmente
                camera.position.y -= 0.3;
            }
        }

        // Função de atualização do jogo (sem mudanças)
        function update() {
            if (gameOver) return;

            const isRunning = keys['ShiftLeft'] || keys['ShiftRight'];
            const baseSpeed = isRunning ? 0.25 : 0.15;
            const speed = stamina > 0 ? baseSpeed : baseSpeed * 0.5;
            let moving = false;
            let moveX = 0, moveZ = 0;

            if (isInTrain) {
                player.position.copy(train.mesh.position);
                player.position.y = 2;
                cameraMode = 'third';
            } else {
                if (cameraMode === 'god') {
                    // Inverter W e S na visão top down
                    if (keys['KeyW']) moveZ = -1; // Invertido
                    if (keys['KeyS']) moveZ = 1;  // Invertido
                    if (keys['KeyA']) moveX = -1;
                    if (keys['KeyD']) moveX = 1;
                } else if (cameraMode === 'first') {
                    // Movimento profissional baseado na câmera FPS
                    const { forward, right } = getFPSMovementDirection();
                    
                    if (keys['KeyW']) {
                        moveX += forward.x;
                        moveZ += forward.z;
                    }
                    if (keys['KeyS']) {
                        moveX -= forward.x;
                        moveZ -= forward.z;
                    }
                    if (keys['KeyA']) {
                        moveX -= right.x;
                        moveZ -= right.z;
                    }
                    if (keys['KeyD']) {
                        moveX += right.x;
                        moveZ += right.z;
                    }
                } else {
                    if (keys['KeyW']) moveZ = 1;
                    if (keys['KeyS']) moveZ = -1;
                    if (keys['KeyA']) moveX = 1;
                    if (keys['KeyD']) moveX = -1;
                }
                if (moveX !== 0 || moveZ !== 0) moving = true;

                if (moving) {
                    const nx = player.position.x + moveX * speed;
                    const nz = player.position.z + moveZ * speed;
                    // DESABILITAR checkCollision temporariamente para testar
                    player.position.x = nx;
                    player.position.z = nz;

                    // Só rotacionar o personagem se não estiver em primeira pessoa
                    if (cameraMode !== 'first') {
                        const targetAngle = Math.atan2(moveX, moveZ);
                        player.rotation.y = targetAngle;
                    }

                    // Movimento sem consumo de stamina para não interferir no pulo
                } else {
                    stamina = Math.min(100, stamina + 0.3);
                }
            }

            // SISTEMA IGUAL ÀS PASSARELAS - FUNCIONA EM TODO LUGAR!
            
            // Aplicar gravidade
            velocity.y -= 0.02;
            player.position.y += velocity.y;
            
            // Detecção de chão igual às passarelas - usando checkCollision
            const playerBox = new THREE.Box3(
                new THREE.Vector3(player.position.x - 1.5, player.position.y - 1, player.position.z - 1.5),
                new THREE.Vector3(player.position.x + 1.5, player.position.y + 2, player.position.z + 1.5)
            );
            
            let onGround = false;
            
            // Verificar passarelas (funciona)
            for (let w of walkways) {
                const walkwayBox = new THREE.Box3().setFromObject(w);
                if (walkwayBox.intersectsBox(playerBox)) {
                    player.position.y = w.position.y + 1.5;
                    velocity.y = 0;
                    onGround = true;
                    break;
                }
            }
            
            // Verificar rampas
            if (!onGround) {
                for (let r of ramps) {
                    const rampBox = new THREE.Box3().setFromObject(r);
                    if (rampBox.intersectsBox(playerBox)) {
                        player.position.y = r.position.y + 1.5;
                        velocity.y = 0;
                        onGround = true;
                        break;
                    }
                }
            }
            
            // Verificar chão normal - ALTURA SIMPLES COMO NAS PASSARELAS
            if (!onGround && player.position.y <= 2.1) {
                player.position.y = 2;
                velocity.y = 0;
                onGround = true;
            }
            
            isOnGround = onGround;
            
            // Pulo ou sair do trem
            if (keys['Space']) {
                if (isInTrain) {
                    // Sair do trem ao pressionar SPACE
                    isInTrain = false;
                    player.position.x += 5; // Sair para o lado
                    player.position.y = 2;
                    velocity.y = 0.5; // Pequeno pulo ao sair
                } else {
                    // Pulo normal fora do trem
                    velocity.y = 0.5;
                }
            }

            // Animação de caminhada - DEPOIS do pulo
            if (moving && !isInTrain) {
                walkCycle += 0.15;
                const swing = Math.sin(walkCycle) * 0.4;
                leftArm.rotation.x = swing;
                rightArm.rotation.x = -swing;
                leftLeg.rotation.x = -swing * 0.8;
                rightLeg.rotation.x = swing * 0.8;
            } else {
                walkCycle = 0;
                leftArm.rotation.x = 0;
                rightArm.rotation.x = 0;
                leftLeg.rotation.x = 0;
                rightLeg.rotation.x = 0;
            }

            pickups.forEach((p, i) => {
                const d = player.position.distanceTo(p.mesh.position);
                if (d < 3) {
                    if (p.type === 'weapon') {
                        hasWeapon = true;
                        document.getElementById('weapon').textContent = 'Bazuca Verde';
                        score += 50;
                    } else if (p.type === 'health') {
                        health = Math.min(100, health + 30);
                    } else if (p.type === 'food') {
                        stamina = Math.min(100, stamina + 70); // Aumentada recuperação de comida para 70
                    }
                    scene.remove(p.mesh);
                    pickups.splice(i, 1);
                }
            });

            if (safeZone && player.position.distanceTo(safeZone.position) < 8) {
                level++;
                score += 100;
                isInTrain = false;
                generateWorld();
                // Reposicionar jogador em local seguro após gerar novo mundo
                player.position.set(15, 2, 27.5);
            }

            const lim = 100;
            player.position.x = Math.max(-lim, Math.min(lim, player.position.x));
            player.position.z = Math.max(-lim, Math.min(lim, player.position.z));

            enemies.forEach((e, i) => {
                if (e.isDead) {
                    e.mesh.rotation.x += 0.05;
                    e.mesh.position.y -= 0.02;
                    if (e.mesh.position.y < -5) {
                        scene.remove(e.mesh);
                        enemies.splice(i, 1);
                    }
                    return;
                }

                const dir = new THREE.Vector3().subVectors(player.position, e.mesh.position).normalize();
                const distToPlayer = player.position.distanceTo(e.mesh.position);
                const nx = e.mesh.position.x + dir.x * e.speed;
                const nz = e.mesh.position.z + dir.z * e.speed;

                let hit = false;
                const r = 2;
                for (let b of buildings) {
                    const box = new THREE.Box3().setFromObject(b);
                    const eBox = new THREE.Box3(
                        new THREE.Vector3(nx - r, e.mesh.position.y, nz - r),
                        new THREE.Vector3(nx + r, e.mesh.position.y + 2, nz + r)
                    );
                    if (box.intersectsBox(eBox)) {
                        hit = true;
                        break;
                    }
                }

                if (!hit) {
                    e.mesh.position.x = nx;
                    e.mesh.position.z = nz;
                }

                e.mesh.rotation.y = Math.atan2(player.position.x - e.mesh.position.x, player.position.z - e.mesh.position.z);

                if (distToPlayer < 3) {
                    e.biteAnimation += 0.3;
                    const head = e.mesh.children[1];
                    if (head) {
                        head.rotation.x = Math.sin(e.biteAnimation) * 0.5;
                    }

                    if (Math.sin(e.biteAnimation) > 0.9) {
                        health -= 0.5;
                        if (health <= 0) {
                            gameOver = true;
                            document.getElementById('gameOver').style.display = 'block';
                        }
                    }
                } else {
                    e.biteAnimation = 0;
                    const head = e.mesh.children[1];
                    if (head) {
                        head.rotation.x = 0;
                    }
                }

                projectiles.forEach((p, pi) => {
                    if (e.mesh.position.distanceTo(p.mesh.position) < 3.5) {
                        e.health--;
                        createExplosion(p.mesh.position);
                        scene.remove(p.mesh);
                        projectiles.splice(pi, 1);

                        e.mesh.children.forEach(child => {
                            if (child.material) {
                                child.material.emissiveIntensity = 2;
                                setTimeout(() => {
                                    if (child.material) child.material.emissiveIntensity = 0.5;
                                }, 100);
                            }
                        });

                        if (e.health <= 0) {
                            e.isDead = true;
                            score += 25;
                        }
                    }
                });
            });

            projectiles.forEach((p, i) => {
                p.mesh.position.add(p.velocity);
                let remove = false;
                for (let b of buildings) {
                    if (new THREE.Box3().setFromObject(b).intersectsBox(new THREE.Box3().setFromObject(p.mesh))) {
                        remove = true;
                        break;
                    }
                }
                if (remove || p.mesh.position.length() > 200) {
                    scene.remove(p.mesh);
                    projectiles.splice(i, 1);
                }
            });

            vehicles.forEach(v => {
                const oldX = v.mesh.position.x;
                v.mesh.position.x += v.speed;
                if (Math.abs(v.mesh.position.x) > 100) v.mesh.position.x = -v.mesh.position.x;
                v.wheels.forEach(w => w.rotation.x += v.speed * 0.5);

                const carBox = new THREE.Box3().setFromObject(v.mesh);
                const playerBox = new THREE.Box3(
                    new THREE.Vector3(player.position.x - 1, player.position.y - 1, player.position.z - 1),
                    new THREE.Vector3(player.position.x + 1, player.position.y + 2, player.position.z + 1)
                );

                if (carBox.intersectsBox(playerBox) && player.position.y < 2.5 && !isInTrain) {
                    health -= 1;
                    const pushDir = new THREE.Vector3().subVectors(player.position, v.mesh.position).normalize();
                    player.position.x += pushDir.x * 2;
                    player.position.z += pushDir.z * 2;

                    v.mesh.children[0].material.emissiveIntensity = 2;
                    setTimeout(() => {
                        if (v.mesh.children[0].material) {
                            v.mesh.children[0].material.emissiveIntensity = 0.5;
                        }
                    }, 100);

                    if (health <= 0) {
                        gameOver = true;
                        document.getElementById('gameOver').style.display = 'block';
                    }
                }
            });

            // Atualizar trem
            if (train) {
                train.mesh.position.x += train.speed;
                if (Math.abs(train.mesh.position.x) > 100) train.mesh.position.x = -train.mesh.position.x;
                train.wheels.forEach(w => w.rotation.x += train.speed * 0.5);

                const trainBox = new THREE.Box3().setFromObject(train.mesh);
                const playerBox = new THREE.Box3(
                    new THREE.Vector3(player.position.x - 1, player.position.y - 1, player.position.z - 1),
                    new THREE.Vector3(player.position.x + 1, player.position.y + 2, player.position.z + 1)
                );

                if (trainBox.intersectsBox(playerBox) && !isInTrain) {
                    isInTrain = true;
                    player.position.copy(train.mesh.position);
                    player.position.y = 2;
                }
            }

            pedestrians.forEach(p => {
                p.walkCycle += 0.1;
                p.mesh.position.x += Math.sin(p.direction) * p.speed;
                p.mesh.position.z += Math.cos(p.direction) * p.speed;
                if (Math.abs(p.mesh.position.x) > 100 || Math.abs(p.mesh.position.z) > 100) {
                    p.direction = Math.random() * Math.PI * 2;
                    const sidewalkIndex = Math.floor(Math.random() * 5);
                    p.mesh.position.x = Math.random() * 80 - 40;
                    p.mesh.position.z = (sidewalkIndex - 2) * 20 + (sidewalkIndex % 2 === 0 ? 7.5 : -7.5);
                }

                if (p.isInteractive && p.mesh.children[2]) {
                    const dist = player.position.distanceTo(p.mesh.position);
                    p.mesh.children[2].visible = dist < 5;
                    if (dist < 5) {
                        p.mesh.children[2].lookAt(camera.position);
                        p.mesh.children[2].position.y = 2 + Math.sin(Date.now() * 0.002) * 0.2;
                    }
                }
            });

            if (safeZone) safeZone.rotation.y += 0.01;

            if (portal) {
                portal.rotation.y += 0.02;
                portal.rotation.z = Math.sin(Date.now() * 0.001) * 0.1;
                portal.children.forEach((child, i) => {
                    if (i < portal.children.length - 1) {
                        child.rotation.x += 0.01 * (i + 1);
                    }
                });
            }

            pickups.forEach(p => {
                p.rotation += 0.02;
                p.mesh.rotation.y = p.rotation;
                p.mesh.position.y = 0.5 + Math.sin(p.rotation * 2) * 0.3;
            });

            document.getElementById('health').textContent = Math.max(0, Math.floor(health));
            document.getElementById('stamina').textContent = Math.max(0, Math.floor(stamina));
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;

            // Atualizar câmera com base no modo
            if (cameraMode === 'first') {
                // Posicionar câmera na altura dos olhos do personagem
                camera.position.copy(player.position);
                camera.position.y += 1.6; // Altura dos olhos humanos
                
                // Aplicar rotação profissional FPS
                camera.rotation.order = 'YXZ'; // Ordem correta para FPS
                camera.rotation.y = fpsCamera.yaw;
                camera.rotation.x = fpsCamera.pitch;
                camera.rotation.z = 0;
                player.visible = false;
                
                // Mostrar arma em primeira pessoa se tiver arma
                if (hasWeapon) {
                    if (!fpsWeaponModel) {
                        fpsWeaponModel = createFPSWeapon();
                        camera.add(fpsWeaponModel);
                    }
                    // Animação de recuo ao atirar
                    if (fpsWeaponModel) {
                        fpsWeaponModel.visible = true;
                    }
                } else if (fpsWeaponModel) {
                    fpsWeaponModel.visible = false;
                }
            } else if (cameraMode === 'god') {
                camera.position.set(player.position.x, player.position.y + 20, player.position.z);
                camera.rotation.set(-Math.PI / 2, 0, 0);
                player.visible = true;
                
                // Ocultar arma FPS em outros modos
                if (fpsWeaponModel) {
                    fpsWeaponModel.visible = false;
                }
            } else {
                const d = 15, h = 8;
                const sway = Math.sin(walkCycle * 0.5) * 0.3;
                camera.position.x = player.position.x + sway;
                camera.position.y = player.position.y + h + Math.sin(walkCycle) * 0.2 + cameraOffset; // Aplicar offset para obstruções
                camera.position.z = player.position.z - d;
                camera.lookAt(player.position.x, player.position.y + 1, player.position.z);
                player.visible = true;
                
                // Ocultar arma FPS em outros modos
                if (fpsWeaponModel) {
                    fpsWeaponModel.visible = false;
                }
            }

            // Ajustar câmera para obstruções
            if (cameraMode === 'third') {
                adjustCameraForObstructions();
            }

            renderer.autoClear = false;
            renderer.clear();
            renderer.render(scene, camera);
            renderer.autoClear = true;
        }

        // Função de animação principal (sem mudanças)
        function animate() {
            requestAnimationFrame(animate);
            if (gameStarted) {
                update();
            } else {
                renderer.render(scene, camera);
            }
        }

        // Iniciar o jogo
        document.getElementById('startBtn').addEventListener('click', () => {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('customizationScreen').style.display = 'flex';
            initCustomizationPreview();
        });

        document.getElementById('confirmBtn').addEventListener('click', () => {
            document.getElementById('customizationScreen').style.display = 'none';
            
            // Remover renderer de preview com verificação de segurança
            if (previewRenderer && previewRenderer.domElement && previewRenderer.domElement.parentNode) {
                previewRenderer.domElement.parentNode.removeChild(previewRenderer.domElement);
            }
            
            gameStarted = true;
            init();
            animate();
        });
    </script>
</body>
</html>
