<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alien: Spaceship Survival</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            font-family: 'Courier New', monospace;
            background: #000;
        }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            font-size: 18px;
            z-index: 100;
            pointer-events: none;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #f00;
            font-size: 72px;
            text-shadow: 0 0 20px #f00;
            display: none;
            z-index: 200;
            text-align: center;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            font-size: 14px;
            text-align: center;
            z-index: 100;
            pointer-events: none;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid #0ff;
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
            box-shadow: 0 0 10px #0ff;
        }
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
            color: #0ff;
            text-shadow: 0 0 20px #0ff;
        }
        #startScreen h1 {
            font-size: 64px;
            margin-bottom: 30px;
        }
        #startBtn {
            font-size: 24px;
            padding: 15px 40px;
            background: transparent;
            border: 2px solid #0ff;
            color: #0ff;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 10px #0ff;
            transition: all 0.3s;
        }
        #startBtn:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 20px #0ff;
        }
        #customizationScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: row;
            justify-content: space-between;
            align-items: center;
            z-index: 250;
            color: #0ff;
            text-shadow: 0 0 20px #0ff;
            padding: 0 50px;
        }
        #customizationScreen h2 {
            font-size: 48px;
            margin-bottom: 20px;
        }
        .customization-left {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-right: 50px;
        }
        .customization-right {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .custom-section {
            margin: 10px 0;
            text-align: center;
        }
        .custom-section label {
            display: block;
            font-size: 20px;
            margin-bottom: 5px;
        }
        .custom-section select, .custom-section button {
            font-size: 18px;
            padding: 5px 10px;
            background: transparent;
            border: 2px solid #0ff;
            color: #0ff;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 5px #0ff;
            transition: all 0.3s;
        }
        .custom-section select:hover, .custom-section button:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 10px #0ff;
        }
        #confirmBtn {
            font-size: 24px;
            padding: 15px 40px;
            margin-top: 20px;
            background: transparent;
            border: 2px solid #0ff;
            color: #0ff;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 10px #0ff;
            transition: all 0.3s;
        }
        #confirmBtn:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 20px #0ff;
        }
        
        /* Controles Mobile */
        #mobileControls {
            display: none;
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 150;
        }
        
        /* Joystick Virtual */
        #joystickContainer {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 150px;
            height: 150px;
            pointer-events: auto;
        }
        
        #joystickBase {
            position: absolute;
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.2);
            border: 3px solid rgba(0, 255, 255, 0.5);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }
        
        #joystickStick {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.6);
            border: 2px solid #0ff;
            box-shadow: 0 0 15px #0ff;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s;
        }
        
        /* Botões de Ação */
        #actionButtons {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: auto;
        }
        
        .action-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.3);
            border: 3px solid #0ff;
            color: #0ff;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            line-height: 64px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            font-family: 'Courier New', monospace;
            user-select: none;
            touch-action: none;
        }
        
        .action-btn:active {
            background: rgba(0, 255, 255, 0.6);
            transform: scale(0.95);
        }
        
        /* Botão de Disparo Grande */
        #shootBtn {
            width: 80px;
            height: 80px;
            line-height: 74px;
            font-size: 16px;
        }
        
        /* Detectar Mobile */
        @media (max-width: 768px), (pointer: coarse) {
            #mobileControls {
                display: block;
            }
            
            #instructions {
                display: none;
            }
            
            #hud {
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1>ALIEN: SPACESHIP SURVIVAL</h1>
        <p style="margin-bottom: 20px;">Sobreviva aos Xenomorphs na espaçonave infectada! Encontre suprimentos e escape!</p>
        <button id="startBtn">INICIAR</button>
    </div>
    <div id="customizationScreen">
        <div class="customization-left">
            <h2>Customizar Personagem</h2>
            <div class="custom-section">
                <label for="hairSelect">Cabelo:</label>
                <select id="hairSelect">
                    <option value="none">Nenhum</option>
                    <option value="short">Curto</option>
                    <option value="long">Longo</option>
                    <option value="mohawk">Moicano</option>
                </select>
            </div>
            <div class="custom-section">
                <label for="backpackSelect">Mochila:</label>
                <select id="backpackSelect">
                    <option value="none">Nenhuma</option>
                    <option value="small">Pequena</option>
                    <option value="large">Grande</option>
                </select>
            </div>
            <div class="custom-section">
                <label for="clothesColor">Cor da Roupa:</label>
                <select id="clothesColor">
                    <option value="0x00aaff">Azul (Padrão)</option>
                    <option value="0xff0000">Vermelho</option>
                    <option value="0x00ff00">Verde</option>
                    <option value="0xffff00">Amarelo</option>
                </select>
            </div>
            <div class="custom-section">
                <label for="jacketSelect">Jaqueta:</label>
                <select id="jacketSelect">
                    <option value="none">Nenhuma</option>
                    <option value="leather">Couro</option>
                    <option value="cyber">Cyberpunk</option>
                </select>
            </div>
            <button id="confirmBtn">CONFIRMAR</button>
        </div>
        <div class="customization-right">
            <!-- Personagem será renderizado aqui -->
        </div>
    </div>
    <div id="hud">
        <div>VIDA: <span id="health">100</span></div>
        <div>STAMINA: <span id="stamina">100</span></div>
        <div>SCORE: <span id="score">0</span></div>
        <div>FASE: <span id="level">1</span></div>
        <div>ARMA: <span id="weapon">Nenhuma</span></div>
    </div>
    <div id="gameOver">
        <div>GAME OVER</div>
        <div style="font-size: 24px; margin-top: 20px;">Pressione R para reiniciar</div>
    </div>
    <div id="instructions">
        WASD: Mover | Espaço: Pular | Clique: Atirar | T: Alternar visão | G: Visão aérea | Q: Inventário | ESC: Sair da primeira pessoa | Escape Pod = Próxima fase
    </div>
    
    <!-- Interface de Inventário -->
    <div id="inventory" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.9); border: 2px solid #00d4ff; padding: 20px; z-index: 200;">
        <h3 style="color: #00d4ff; text-align: center; margin-bottom: 20px;">INVENTÁRIO DE ARMAS</h3>
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; width: 300px;">
            <div id="weapon-0" class="weapon-slot" style="border: 2px solid #00d4ff; padding: 10px; text-align: center; background: rgba(0, 212, 255, 0.1);">
                <div style="color: #00d4ff; font-weight: bold;">Laser Gun</div>
                <div style="color: #ffffff;">∞</div>
            </div>
            <div id="weapon-1" class="weapon-slot" style="border: 2px solid #666; padding: 10px; text-align: center; background: rgba(0, 0, 0, 0.5);">
                <div style="color: #666; font-weight: bold;">Granadas</div>
                <div style="color: #666;">0/5</div>
            </div>
            <div id="weapon-2" class="weapon-slot" style="border: 2px solid #666; padding: 10px; text-align: center; background: rgba(0, 0, 0, 0.5);">
                <div style="color: #666; font-weight: bold;">Minas</div>
                <div style="color: #666;">0/5</div>
            </div>
            <div id="weapon-3" class="weapon-slot" style="border: 2px solid #666; padding: 10px; text-align: center; background: rgba(0, 0, 0, 0.5);">
                <div style="color: #666; font-weight: bold;">Lança-chamas</div>
                <div style="color: #666;">0/5</div>
            </div>
            <div id="weapon-4" class="weapon-slot" style="border: 2px solid #666; padding: 10px; text-align: center; background: rgba(0, 0, 0, 0.5);">
                <div style="color: #666; font-weight: bold;">Bazuca Plasma</div>
                <div style="color: #666;">0/5</div>
            </div>
        </div>
        <div style="text-align: center; margin-top: 15px; color: #00d4ff;">Pressione Q para fechar</div>
    </div>
    <div id="crosshair"></div>
    
    <!-- Controles Mobile -->
    <div id="mobileControls">
        <!-- Joystick Virtual -->
        <div id="joystickContainer">
            <div id="joystickBase"></div>
            <div id="joystickStick"></div>
        </div>
        
        <!-- Botões de Ação -->
        <div id="actionButtons">
            <div class="action-btn" id="jumpBtn">PULAR</div>
            <div class="action-btn" id="shootBtn">ATIRAR</div>
            <div class="action-btn" id="viewBtn">VISÃO</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Variáveis globais
        let scene, camera, renderer, player;
        let enemies = [], buildings = [], vehicles = [], projectiles = [], pickups = [], pedestrians = [], sidewalks = [], roads = [], walkways = [], ramps = [], train;
        let safeZone, portal;
        let health = 100, stamina = 100, score = 0, level = 1, hasWeapon = false;
        let gameOver = false, gameStarted = false;
        let keys = {}, velocity = new THREE.Vector3();
        let isOnGround = true, walkCycle = 0;
        let leftArm, rightArm, leftLeg, rightLeg;
        let cameraMode = 'third'; // 'third', 'first', 'god'
        let worldTheme = 0;
        let isInTrain = false;
        let raycaster = new THREE.Raycaster();
        let cameraOffset = 0; // Para ajustar altura da câmera em caso de obstrução
        let fpsWeaponModel = null; // Modelo da arma para primeira pessoa

        // Sistema de armas e inventário
        let currentWeapon = 0; // 0 = Laser Gun (infinita), 1 = Granada, 2 = Mina, 3 = Lança-chamas, 4 = Bazuca de energia
        let weapons = [
            { name: 'Laser Gun', ammo: -1, maxAmmo: -1, damage: 1, type: 'laser' }, // -1 = infinita
            { name: 'Granada', ammo: 0, maxAmmo: 5, damage: 3, type: 'explosive' },
            { name: 'Mina', ammo: 0, maxAmmo: 5, damage: 2, type: 'mine' },
            { name: 'Lança-chamas', ammo: 0, maxAmmo: 5, damage: 2, type: 'flame' },
            { name: 'Bazuca Plasma', ammo: 0, maxAmmo: 5, damage: 4, type: 'plasma' }
        ];
        let showInventory = false;
        let doors = []; // Sistema de portas
        let elevators = []; // Sistema de elevadores
        let boss = null; // Boss do jogo
        
        // Sistema profissional de câmera primeira pessoa
        let fpsCamera = {
            yaw: 0,           // Rotação horizontal (esquerda/direita)
            pitch: 0,         // Rotação vertical (cima/baixo)
            isLocked: false,  // Se o mouse está bloqueado
            sensitivity: 0.002, // Sensibilidade do mouse
            maxPitch: Math.PI / 2 - 0.1, // Limite máximo de inclinação
            minPitch: -Math.PI / 2 + 0.1  // Limite mínimo de inclinação
        };

        // Variáveis para customização
        let previewScene, previewCamera, previewRenderer, previewPlayer;
        let customHair, customBackpack, customJacket;
        let customClothesColor = 0x00aaff;
        
        // Controles Mobile
        let mobileJoystick = {
            active: false,
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            deltaX: 0,
            deltaY: 0
        };
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // Função para atualizar a orientação da câmera FPS
        function updateFPSCamera(deltaX, deltaY) {
            if (!fpsCamera.isLocked) return;
            
            // Atualizar yaw (rotação horizontal)
            fpsCamera.yaw -= deltaX * fpsCamera.sensitivity;
            
            // Atualizar pitch (rotação vertical) com limitações
            fpsCamera.pitch -= deltaY * fpsCamera.sensitivity;
            fpsCamera.pitch = Math.max(fpsCamera.minPitch, Math.min(fpsCamera.maxPitch, fpsCamera.pitch));
        }

        // Função para calcular direção de movimento baseada na câmera FPS
        function getFPSMovementDirection() {
            const forward = new THREE.Vector3(0, 0, -1); // usar -Z como frente
            const right = new THREE.Vector3(1, 0, 0);
            
            // Aplicar rotação yaw (horizontal)
            forward.applyEuler(new THREE.Euler(0, fpsCamera.yaw, 0));
            right.applyEuler(new THREE.Euler(0, fpsCamera.yaw, 0));
            
            return { forward, right };
        }

        // Função para solicitar bloqueio do ponteiro
        function requestPointerLock() {
            if (cameraMode === 'first' && !fpsCamera.isLocked) {
                document.body.requestPointerLock();
            }
        }

        // Função para liberar bloqueio do ponteiro
        function exitPointerLock() {
            if (fpsCamera.isLocked) {
                document.exitPointerLock();
            }
        }

        // Função para criar o jogador (agora com opções de customização)
        function createPlayer(customOptions = {}) {
            const group = new THREE.Object3D();
            const bodyMat = new THREE.MeshStandardMaterial({ color: customOptions.clothesColor || 0x00aaff, emissive: 0x003366, emissiveIntensity: 0.44 }); // Aumentado de 0.2 para 0.44 (120% mais brilho)

            const body = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.2, 0.4), bodyMat);
            body.position.y = 0.6;
            group.add(body);

            const head = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), new THREE.MeshStandardMaterial({ color: 0xffcc99 }));
            head.position.y = 1.5;
            group.add(head);

            leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.8, 0.25), bodyMat);
            leftArm.position.set(-0.55, 0.6, 0);
            group.add(leftArm);

            rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.8, 0.25), bodyMat);
            rightArm.position.set(0.55, 0.6, 0);
            group.add(rightArm);

            const legMat = new THREE.MeshStandardMaterial({ color: 0x003366 });
            leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.9, 0.3), legMat);
            leftLeg.position.set(-0.25, -0.45, 0);
            group.add(leftLeg);

            rightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.9, 0.3), legMat);
            rightLeg.position.set(0.25, -0.45, 0);
            group.add(rightLeg);

            // Adicionar customizações
            if (customOptions.hair) {
                let hairGeom, hairMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
                if (customOptions.hair === 'short') {
                    hairGeom = new THREE.BoxGeometry(0.65, 0.2, 0.65);
                } else if (customOptions.hair === 'long') {
                    hairGeom = new THREE.BoxGeometry(0.65, 0.5, 0.65);
                } else if (customOptions.hair === 'mohawk') {
                    hairGeom = new THREE.BoxGeometry(0.2, 0.4, 0.65);
                }
                customHair = new THREE.Mesh(hairGeom, hairMat);
                customHair.position.set(0, 1.8 + (customOptions.hair === 'long' ? 0.15 : 0), 0);
                group.add(customHair);
            }

            if (customOptions.backpack) {
                let backpackGeom, backpackMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
                if (customOptions.backpack === 'small') {
                    backpackGeom = new THREE.BoxGeometry(0.7, 0.8, 0.5);
                } else if (customOptions.backpack === 'large') {
                    backpackGeom = new THREE.BoxGeometry(0.9, 1.0, 0.6);
                }
                customBackpack = new THREE.Mesh(backpackGeom, backpackMat);
                customBackpack.position.set(0, 0.6, -0.45);
                group.add(customBackpack);
            }

            if (customOptions.jacket) {
                let jacketGeom, jacketMat = new THREE.MeshStandardMaterial({ color: customOptions.jacket === 'leather' ? 0x4a2700 : 0x00ffff });
                jacketGeom = new THREE.BoxGeometry(0.9, 1.3, 0.5);
                customJacket = new THREE.Mesh(jacketGeom, jacketMat);
                customJacket.position.set(0, 0.6, 0);
                group.add(customJacket);
            }

            return group;
        }

        // Função para inicializar a cena de preview de customização
        function initCustomizationPreview() {
            previewScene = new THREE.Scene();
            previewScene.background = new THREE.Color(0x000000);
            previewScene.fog = new THREE.FogExp2(0x000000, 0.1);

            // Calcular tamanho da área direita (metade da tela)
            const rightAreaWidth = window.innerWidth / 2;
            const rightAreaHeight = window.innerHeight;

            previewCamera = new THREE.PerspectiveCamera(75, rightAreaWidth / rightAreaHeight, 0.1, 1000);
            previewRenderer = new THREE.WebGLRenderer({ antialias: true });
            previewRenderer.setSize(rightAreaWidth, rightAreaHeight);
            
            // Adicionar o renderer à área direita
            const rightArea = document.querySelector('.customization-right');
            if (rightArea) {
                rightArea.appendChild(previewRenderer.domElement);
            } else {
                // Fallback: adicionar ao body se a área direita não for encontrada
                document.body.appendChild(previewRenderer.domElement);
                console.log('Área direita não encontrada, usando fallback');
            }

            // Aumentar brilho com mais luzes
            previewScene.add(new THREE.AmbientLight(0xffffff, 1.2)); // Aumentado de 0.5 para 1.2
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.6); // Aumentado de 0.8 para 1.6
            dirLight.position.set(5, 10, 5);
            previewScene.add(dirLight);
            
            // Adicionar luz adicional para mais brilho
            const extraLight = new THREE.DirectionalLight(0xffffff, 0.8);
            extraLight.position.set(-5, 10, -5);
            previewScene.add(extraLight);

            previewCamera.position.set(0, 2, 5);
            previewCamera.lookAt(0, 1.5, 0);

            // Aguardar um frame antes de criar o player para garantir que os elementos HTML estejam prontos
            setTimeout(() => {
                updatePreviewPlayer();
            }, 100);

            function animatePreview() {
                requestAnimationFrame(animatePreview);
                if (previewPlayer) {
                    previewPlayer.rotation.y += 0.01;
                }
                previewRenderer.render(previewScene, previewCamera);
            }
            animatePreview();

            window.addEventListener('resize', () => {
                const newRightAreaWidth = window.innerWidth / 2;
                const newRightAreaHeight = window.innerHeight;
                previewCamera.aspect = newRightAreaWidth / newRightAreaHeight;
                previewCamera.updateProjectionMatrix();
                previewRenderer.setSize(newRightAreaWidth, newRightAreaHeight);
            });
        }

        // Função para atualizar o player de preview com as opções selecionadas
        function updatePreviewPlayer() {
            if (previewPlayer) previewScene.remove(previewPlayer);

            // Verificar se os elementos HTML existem antes de acessá-los
            const hairSelect = document.getElementById('hairSelect');
            const backpackSelect = document.getElementById('backpackSelect');
            const clothesColorSelect = document.getElementById('clothesColor');
            const jacketSelect = document.getElementById('jacketSelect');

            if (!hairSelect || !backpackSelect || !clothesColorSelect || !jacketSelect) {
                console.log('Elementos HTML ainda não estão prontos, aguardando...');
                return;
            }

            const hair = hairSelect.value;
            const backpack = backpackSelect.value;
            const clothesColor = parseInt(clothesColorSelect.value);
            const jacket = jacketSelect.value;

            previewPlayer = createPlayer({ hair, backpack, clothesColor, jacket });
            previewPlayer.position.set(0, 0, 0);
            previewScene.add(previewPlayer);
        }

        // Função para aplicar customizações ao player do jogo
        function applyCustomizations() {
            const hair = document.getElementById('hairSelect').value;
            const backpack = document.getElementById('backpackSelect').value;
            customClothesColor = parseInt(document.getElementById('clothesColor').value);
            const jacket = document.getElementById('jacketSelect').value;

            player = createPlayer({ hair, backpack, clothesColor: customClothesColor, jacket });
            // Spawn na espaçonave
            player.position.set(0, 2, 0); // Centro da espaçonave
            scene.add(player);
        }

        // Adicionar event listeners para atualizar preview em tempo real
        document.getElementById('hairSelect').addEventListener('change', updatePreviewPlayer);
        document.getElementById('backpackSelect').addEventListener('change', updatePreviewPlayer);
        document.getElementById('clothesColor').addEventListener('change', updatePreviewPlayer);
        document.getElementById('jacketSelect').addEventListener('change', updatePreviewPlayer);

        // Função para criar Xenomorph (Alien)
        function createXenomorph() {
            const group = new THREE.Object3D();
            const bodyMat = new THREE.MeshStandardMaterial({ 
                color: 0x000000, 
                emissive: 0x004400, 
                emissiveIntensity: 0.3,
                roughness: 0.9,
                metalness: 0.1
            });

            // Corpo principal - mais alongado e orgânico
            const body = new THREE.Mesh(new THREE.BoxGeometry(2.5, 2, 4), bodyMat);
            body.position.y = 1;
            group.add(body);

            // Cabeça alongada característica do Alien
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.5, 2.5), bodyMat);
            head.position.set(0, 1.5, 2.8);
            head.rotation.x = -0.1;
            group.add(head);

            // Crânio alongado
            const skull = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.2, 2), bodyMat);
            skull.position.set(0, 2.2, 3.5);
            group.add(skull);

            // Cauda longa e flexível
            const tail = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 4), bodyMat);
            tail.position.set(0, 0.8, -3);
            tail.rotation.x = 0.2;
            group.add(tail);

            // Pernas dianteiras mais longas
            const frontLeg1 = new THREE.Mesh(new THREE.BoxGeometry(0.3, 2, 0.3), bodyMat);
            frontLeg1.position.set(-0.8, 0, 1);
            group.add(frontLeg1);

            const frontLeg2 = new THREE.Mesh(new THREE.BoxGeometry(0.3, 2, 0.3), bodyMat);
            frontLeg2.position.set(0.8, 0, 1);
            group.add(frontLeg2);

            // Pernas traseiras
            const backLeg1 = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.8, 0.3), bodyMat);
            backLeg1.position.set(-0.8, 0, -1.5);
            group.add(backLeg1);

            const backLeg2 = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.8, 0.3), bodyMat);
            backLeg2.position.set(0.8, 0, -1.5);
            group.add(backLeg2);

            // Olhos brilhantes (sem íris)
            const eyeMat = new THREE.MeshStandardMaterial({ 
                color: 0x000000, 
                emissive: 0x00ff00, 
                emissiveIntensity: 0.8 
            });
            const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.15), eyeMat);
            eye1.position.set(-0.25, 2.1, 4.2);
            group.add(eye1);

            const eye2 = new THREE.Mesh(new THREE.SphereGeometry(0.15), eyeMat);
            eye2.position.set(0.25, 2.1, 4.2);
            group.add(eye2);

            // Mandíbula interna (dentes)
            const jaw = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.3, 0.8), bodyMat);
            jaw.position.set(0, 1.2, 4.5);
            group.add(jaw);

            return group;
        }

        // Função para criar Facehugger (menor)
        function createFacehugger() {
            const group = new THREE.Object3D();
            const bodyMat = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a1a, 
                emissive: 0x004400, 
                emissiveIntensity: 0.2 
            });

            // Corpo pequeno e achatado
            const body = new THREE.Mesh(new THREE.BoxGeometry(1, 0.3, 1), bodyMat);
            body.position.y = 0.15;
            group.add(body);

            // Pernas longas e finas
            for (let i = 0; i < 8; i++) {
                const leg = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.8, 0.1), bodyMat);
                const angle = (i / 8) * Math.PI * 2;
                leg.position.set(
                    Math.cos(angle) * 0.6,
                    0.4,
                    Math.sin(angle) * 0.6
                );
                group.add(leg);
            }

            // Cauda longa
            const tail = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 1.5), bodyMat);
            tail.position.set(0, 0.15, -0.8);
            group.add(tail);

            return group;
        }

        // Função para criar Boss (Alien Queen)
        function createAlienBoss() {
            const group = new THREE.Object3D();
            const bodyMat = new THREE.MeshStandardMaterial({ 
                color: 0x000000, 
                emissive: 0x004400, 
                emissiveIntensity: 0.4,
                roughness: 0.9,
                metalness: 0.1
            });

            // Corpo principal - muito maior que Xenomorph normal
            const body = new THREE.Mesh(new THREE.BoxGeometry(4, 3, 6), bodyMat);
            body.position.y = 1.5;
            group.add(body);

            // Cabeça massiva
            const head = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2.5, 3.5), bodyMat);
            head.position.set(0, 2.5, 4);
            head.rotation.x = -0.1;
            group.add(head);

            // Crânio alongado ainda maior
            const skull = new THREE.Mesh(new THREE.BoxGeometry(1.2, 2, 2.5), bodyMat);
            skull.position.set(0, 3.5, 5.5);
            group.add(skull);

            // Cauda gigante
            const tail = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 6), bodyMat);
            tail.position.set(0, 1.5, -4);
            tail.rotation.x = 0.3;
            group.add(tail);

            // Pernas dianteiras enormes
            const frontLeg1 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 3.5, 0.5), bodyMat);
            frontLeg1.position.set(-1.5, 0, 2);
            group.add(frontLeg1);

            const frontLeg2 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 3.5, 0.5), bodyMat);
            frontLeg2.position.set(1.5, 0, 2);
            group.add(frontLeg2);

            // Pernas traseiras
            const backLeg1 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 3, 0.5), bodyMat);
            backLeg1.position.set(-1.5, 0, -2);
            group.add(backLeg1);

            const backLeg2 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 3, 0.5), bodyMat);
            backLeg2.position.set(1.5, 0, -2);
            group.add(backLeg2);

            // Olhos vermelhos brilhantes (diferentes dos Xenomorphs normais)
            const eyeMat = new THREE.MeshStandardMaterial({ 
                color: 0x000000, 
                emissive: 0xff0000, 
                emissiveIntensity: 1 
            });
            const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.25), eyeMat);
            eye1.position.set(-0.5, 3.8, 6.5);
            group.add(eye1);

            const eye2 = new THREE.Mesh(new THREE.SphereGeometry(0.25), eyeMat);
            eye2.position.set(0.5, 3.8, 6.5);
            group.add(eye2);

            // Mandíbula interna gigante
            const jaw = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 1.2), bodyMat);
            jaw.position.set(0, 2, 6.8);
            group.add(jaw);

            // Chifres/cristas na cabeça
            for (let i = 0; i < 5; i++) {
                const horn = new THREE.Mesh(
                    new THREE.ConeGeometry(0.2, 1, 6),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x000000, 
                        emissive: 0x004400, 
                        emissiveIntensity: 0.6 
                    })
                );
                horn.position.set(-0.8 + i * 0.4, 4.5, 5);
                group.add(horn);
            }

            return group;
        }

        // Função para criar rótulos (sem mudanças)
        function createLabel(text, color, scale = 5) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;
            ctx.fillStyle = color;
            ctx.font = 'bold 60px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(text, 256, 64);

            const texture = new THREE.CanvasTexture(canvas);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture, transparent: true }));
            sprite.scale.set(scale, scale / 4, 1);
            return sprite;
        }

        // Função para criar portas
        function createDoor(x, y, z, width = 2, height = 4, thickness = 0.2, isOpen = false) {
            const doorGroup = new THREE.Object3D();
            
            // Porta
            const door = new THREE.Mesh(
                new THREE.BoxGeometry(width, height, thickness),
                new THREE.MeshStandardMaterial({ 
                    color: 0x2a2a2a,
                    emissive: 0x004400,
                    emissiveIntensity: 0.1
                })
            );
            door.position.set(x, y + height/2, z);
            doorGroup.add(door);

            // Moldura da porta
            const frame = new THREE.Mesh(
                new THREE.BoxGeometry(width + 0.4, height + 0.4, 0.1),
                new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a1a,
                    emissive: 0x004400,
                    emissiveIntensity: 0.05
                })
            );
            frame.position.set(x, y + height/2, z - 0.05);
            doorGroup.add(frame);

            // Botão para abrir/fechar
            const button = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 16, 16),
                new THREE.MeshStandardMaterial({ 
                    color: 0x00ff00,
                    emissive: 0x00ff00,
                    emissiveIntensity: 0.8
                })
            );
            button.position.set(x + width/2 + 0.5, y + height/2, z);
            doorGroup.add(button);

            doorGroup.door = door;
            doorGroup.button = button;
            doorGroup.isOpen = isOpen;
            doorGroup.originalX = x;
            doorGroup.width = width;

            return doorGroup;
        }

        // Função para criar elevadores funcionais
        function createFunctionalElevator(x, z, isOnFirstFloor = true) {
            const elevatorGroup = new THREE.Object3D();
            
            // Poço do elevador
            const shaft = new THREE.Mesh(
                new THREE.BoxGeometry(4, 20, 4),
                new THREE.MeshStandardMaterial({ 
                    color: 0x2a2a2a,
                    emissive: 0x004400,
                    emissiveIntensity: 0.1
                })
            );
            shaft.position.set(x, 10, z);
            elevatorGroup.add(shaft);

            // Plataforma do elevador
            const platform = new THREE.Mesh(
                new THREE.BoxGeometry(3.5, 0.5, 3.5),
                new THREE.MeshStandardMaterial({ 
                    color: 0x00d4ff,
                    emissive: 0x00d4ff,
                    emissiveIntensity: 0.5
                })
            );
            platform.position.set(x, isOnFirstFloor ? 2.25 : 12.25, z);
            elevatorGroup.add(platform);

            // Botões do elevador
            const buttonUp = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 16, 16),
                new THREE.MeshStandardMaterial({ 
                    color: 0x00ff00,
                    emissive: 0x00ff00,
                    emissiveIntensity: 0.8
                })
            );
            buttonUp.position.set(x + 1.5, 2.5, z);
            elevatorGroup.add(buttonUp);

            const buttonDown = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 16, 16),
                new THREE.MeshStandardMaterial({ 
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.8
                })
            );
            buttonDown.position.set(x - 1.5, 2.5, z);
            elevatorGroup.add(buttonDown);

            elevatorGroup.platform = platform;
            elevatorGroup.buttonUp = buttonUp;
            elevatorGroup.buttonDown = buttonDown;
            elevatorGroup.isMoving = false;
            elevatorGroup.targetFloor = isOnFirstFloor ? 1 : 2;
            elevatorGroup.currentFloor = isOnFirstFloor ? 1 : 2;

            return elevatorGroup;
        }

        // Função para criar mão com arma para primeira pessoa
        function createFPSWeapon() {
            const group = new THREE.Object3D();
            
            // Mão direita
            const handMat = new THREE.MeshStandardMaterial({ color: 0xffcc99 });
            const hand = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.3), handMat);
            hand.position.set(0, 0, 0);
            group.add(hand);
            
            // Braço
            const arm = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.12, 0.4), handMat);
            arm.position.set(0, 0, -0.35);
            group.add(arm);
            
            // Bazuca verde
            const weaponMat = new THREE.MeshStandardMaterial({ 
                color: 0x00ff00, 
                emissive: 0x00ff00, 
                emissiveIntensity: 0.5 
            });
            
            // Corpo da bazuca
            const weaponBody = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.8), weaponMat);
            weaponBody.position.set(0, -0.05, 0.4);
            group.add(weaponBody);
            
            // Gatilho
            const trigger = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.08, 0.05), new THREE.MeshStandardMaterial({ color: 0x333333 }));
            trigger.position.set(0, -0.12, 0.1);
            group.add(trigger);
            
            // Bico da bazuca
            const nozzle = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.18, 0.15), weaponMat);
            nozzle.position.set(0, -0.05, 0.85);
            group.add(nozzle);
            
            // Posicionar no canto inferior direito da tela
            group.position.set(0.3, -0.25, -0.5);
            group.rotation.y = -0.1;
            
            return group;
        }

        // Função para criar pedestre (sem mudanças)
        function createPedestrian(isInteractive = false) {
            const group = new THREE.Object3D();
            const colors = [0xff00ff, 0x00ffff, 0xffff00, 0xff0088, 0x00ff88];
            const color = colors[Math.floor(Math.random() * colors.length)];
            const bodyMat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.3 });

            const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1, 0.3), bodyMat);
            body.position.y = 0.5;
            group.add(body);

            const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), new THREE.MeshStandardMaterial({ color: 0xffcc99 }));
            head.position.y = 1.2;
            group.add(head);

            if (isInteractive) {
                const label = createLabel('Portal está a ' + (Math.random() > 0.5 ? 'norte' : 'sul'), '#ffffff', 6); // Aumentado scale para 6
                label.position.y = 2;
                label.visible = false;
                group.add(label);
            }

            return group;
        }

        // Função para criar cruz vermelha (medicamento) (sem mudanças)
        function createRedCross() {
            const group = new THREE.Object3D();
            const mat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.9 });

            const vertical = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.6, 0.4), mat);
            vertical.position.y = 0.8;
            group.add(vertical);

            const horizontal = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.4, 0.4), mat);
            horizontal.position.y = 0.8;
            group.add(horizontal);

            return group;
        }

        // Função para criar trem (sem mudanças)
        function createTrain() {
            const group = new THREE.Object3D();
            const mat = new THREE.MeshStandardMaterial({ color: 0x333333, emissive: 0x00ffff, emissiveIntensity: 0.5 });

            const body = new THREE.Mesh(new THREE.BoxGeometry(10, 3, 4), mat);
            body.position.y = 1.5;
            group.add(body);

            const wheels = [];
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
            const wheelGeom = new THREE.CylinderGeometry(0.6, 0.6, 0.4, 16);

            for (let i = -1; i <= 1; i += 2) {
                for (let j = -1; j <= 1; j += 2) {
                    const wheel = new THREE.Mesh(wheelGeom, wheelMat);
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(i * 3, 0.3, j * 2);
                    group.add(wheel);
                    wheels.push(wheel);
                }
            }

            return { mesh: group, wheels, speed: 0.3, axis: 'x' };
        }

        // Função para criar explosão (sem mudanças)
        function createExplosion(position) {
            const explosionGroup = new THREE.Object3D();

            for (let i = 0; i < 8; i++) {
                const size = Math.random() * 1.5 + 0.5;
                const sphere = new THREE.Mesh(
                    new THREE.SphereGeometry(size, 8, 8),
                    new THREE.MeshStandardMaterial({
                        color: Math.random() > 0.5 ? 0xff6600 : 0xffff00,
                        emissive: Math.random() > 0.5 ? 0xff6600 : 0xffff00,
                        emissiveIntensity: 2,
                        transparent: true,
                        opacity: 1
                    })
                );
                sphere.position.set(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                );
                explosionGroup.add(sphere);
            }

            explosionGroup.position.copy(position);
            scene.add(explosionGroup);

            let scale = 1;
            const interval = setInterval(() => {
                scale += 0.3;
                explosionGroup.scale.set(scale, scale, scale);
                explosionGroup.children.forEach(child => {
                    child.material.opacity -= 0.1;
                });

                if (scale > 4) {
                    clearInterval(interval);
                    scene.remove(explosionGroup);
                }
            }, 50);
        }

        // Função para inicializar a cena do jogo (sem mudanças significativas)
        function init() {
            scene = new THREE.Scene();
            updateWorldTheme();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Iluminação sombria e atmosférica do Alien
            scene.add(new THREE.AmbientLight(0x000a0a, 0.1)); // Muito escuro
            const mainLight = new THREE.DirectionalLight(0x004400, 0.3); // Verde sombrio
            mainLight.position.set(50, 100, 50);
            scene.add(mainLight);
            
            // Luz de emergência vermelha
            const emergencyLight = new THREE.DirectionalLight(0x8b0000, 0.2);
            emergencyLight.position.set(-50, 80, -50);
            scene.add(emergencyLight);
            
            // Luz ácida verde
            const acidLight = new THREE.PointLight(0x00ff00, 0.5, 30);
            acidLight.position.set(0, 5, 0);
            scene.add(acidLight);

            // Adicionar mais spots de luz para iluminar o ambiente
            const lightPositions = [
                [20, 8, 20], [-20, 8, 20], [20, 8, -20], [-20, 8, -20],
                [0, 8, 30], [0, 8, -30], [30, 8, 0], [-30, 8, 0],
                [15, 15, 15], [-15, 15, 15], [15, 15, -15], [-15, 15, -15]
            ];

            lightPositions.forEach((pos, i) => {
                const spotLight = new THREE.PointLight(0x00d4ff, 0.3, 25);
                spotLight.position.set(pos[0], pos[1], pos[2]);
                scene.add(spotLight);

                // Adicionar luz de emergência vermelha em alguns pontos
                if (i % 3 === 0) {
                    const emergencySpot = new THREE.PointLight(0x8b0000, 0.2, 20);
                    emergencySpot.position.set(pos[0], pos[1] + 2, pos[2]);
                    scene.add(emergencySpot);
                }
            });

            applyCustomizations(); // Aplicar customizações ao player

            generateWorld();

            document.addEventListener('keydown', e => {
                keys[e.code] = true;
                if (e.code === 'KeyR' && gameOver) location.reload();
                if (e.code === 'KeyT' && !gameOver && gameStarted) {
                    const previousMode = cameraMode;
                    cameraMode = cameraMode === 'first' ? 'third' : 'first';
                    
                    // Gerenciar bloqueio do ponteiro ao alternar modos
                    if (previousMode === 'first' && cameraMode !== 'first') {
                        exitPointerLock();
                    } else if (cameraMode === 'first') {
                        // Resetar orientação da câmera FPS ao entrar no modo
                        fpsCamera.yaw = player.rotation.y;
                        fpsCamera.pitch = 0;
                    }
                }
                if (e.code === 'KeyG' && !gameOver && gameStarted) {
                    cameraMode = cameraMode === 'god' ? 'third' : 'god';
                }
                if (e.code === 'Space') {
                    e.preventDefault(); // impedir comportamento padrão SEMPRE
                }
            });
            document.addEventListener('keyup', e => {
                keys[e.code] = false;
                if (e.code === 'Space') { e.preventDefault(); }
            });
            document.addEventListener('click', () => {
                if (!hasWeapon || gameOver || !gameStarted) return;
                const proj = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3),
                    new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 1 })
                );
                
                // Ajustar origem do tiro baseado no modo de câmera
                if (cameraMode === 'first') {
                    // Tiro sai da câmera em primeira pessoa
                    proj.position.copy(camera.position);
                    
                    // Direção baseada na rotação da câmera FPS
                    const dir = new THREE.Vector3(0, 0, -1);
                    dir.applyEuler(new THREE.Euler(fpsCamera.pitch, fpsCamera.yaw, 0, 'YXZ'));
                    
                    projectiles.push({ mesh: proj, velocity: dir.multiplyScalar(0.8) });
                    
                    // Animação de recuo da arma
                    if (fpsWeaponModel) {
                        const originalZ = fpsWeaponModel.position.z;
                        fpsWeaponModel.position.z -= 0.1;
                        setTimeout(() => {
                            if (fpsWeaponModel) fpsWeaponModel.position.z = originalZ;
                        }, 50);
                    }
                } else {
                    // Tiro sai do jogador em terceira pessoa
                    proj.position.copy(player.position);
                    proj.position.y += 1;
                    const dir = new THREE.Vector3(
                        Math.sin(player.rotation.y),
                        0,
                        Math.cos(player.rotation.y)
                    );
                    projectiles.push({ mesh: proj, velocity: dir.multiplyScalar(0.8) });
                }
                
                scene.add(proj);
            });

            // Sistema profissional de controle de mouse para primeira pessoa
            document.addEventListener('mousemove', (e) => {
                if (cameraMode === 'first' && fpsCamera.isLocked) {
                    updateFPSCamera(e.movementX, e.movementY);
                }
            });

            // Solicitar bloqueio de ponteiro para primeira pessoa
            document.addEventListener('click', () => {
                requestPointerLock();
            });

            // Gerenciar mudanças no bloqueio do ponteiro
            document.addEventListener('pointerlockchange', () => {
                fpsCamera.isLocked = document.pointerLockElement === document.body;
                
                // Se sair da primeira pessoa, liberar o bloqueio
                if (cameraMode !== 'first') {
                    exitPointerLock();
                }
            });

            // Liberar bloqueio ao pressionar ESC
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Escape' && fpsCamera.isLocked) {
                    exitPointerLock();
                }
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Inicializar controles mobile
            if (isMobile) {
                initMobileControls();
            }
        }
        
        // Funções de controle mobile
        function initMobileControls() {
            const joystickContainer = document.getElementById('joystickContainer');
            const joystickStick = document.getElementById('joystickStick');
            const jumpBtn = document.getElementById('jumpBtn');
            const shootBtn = document.getElementById('shootBtn');
            const viewBtn = document.getElementById('viewBtn');
            
            // Joystick touch events
            joystickContainer.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = joystickContainer.getBoundingClientRect();
                mobileJoystick.active = true;
                mobileJoystick.startX = rect.left + rect.width / 2;
                mobileJoystick.startY = rect.top + rect.height / 2;
                mobileJoystick.currentX = touch.clientX;
                mobileJoystick.currentY = touch.clientY;
                updateJoystickPosition();
            });
            
            joystickContainer.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!mobileJoystick.active) return;
                const touch = e.touches[0];
                mobileJoystick.currentX = touch.clientX;
                mobileJoystick.currentY = touch.clientY;
                updateJoystickPosition();
            });
            
            joystickContainer.addEventListener('touchend', (e) => {
                e.preventDefault();
                mobileJoystick.active = false;
                mobileJoystick.deltaX = 0;
                mobileJoystick.deltaY = 0;
                joystickStick.style.transform = 'translate(-50%, -50%)';
                // Resetar teclas de movimento
                keys['KeyW'] = false;
                keys['KeyA'] = false;
                keys['KeyS'] = false;
                keys['KeyD'] = false;
            });
            
            // Botão de pulo
            jumpBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys['Space'] = true;
            });
            
            jumpBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys['Space'] = false;
            });
            
            // Botão de atirar
            shootBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (!hasWeapon || gameOver || !gameStarted) return;
                
                // Simular clique para atirar
                const clickEvent = new MouseEvent('click', {
                    view: window,
                    bubbles: true,
                    cancelable: true
                });
                document.dispatchEvent(clickEvent);
            });
            
            // Botão de alternar visão
            viewBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameOver || !gameStarted) return;
                
                const previousMode = cameraMode;
                cameraMode = cameraMode === 'first' ? 'third' : 'first';
                
                if (previousMode === 'first' && cameraMode !== 'first') {
                    exitPointerLock();
                } else if (cameraMode === 'first') {
                    fpsCamera.yaw = player.rotation.y;
                    fpsCamera.pitch = 0;
                }
            });
        }
        
        function updateJoystickPosition() {
            const joystickStick = document.getElementById('joystickStick');
            
            // Calcular delta
            const deltaX = mobileJoystick.currentX - mobileJoystick.startX;
            const deltaY = mobileJoystick.currentY - mobileJoystick.startY;
            
            // Limitar distância máxima do joystick
            const maxDistance = 45;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            if (distance > maxDistance) {
                const angle = Math.atan2(deltaY, deltaX);
                mobileJoystick.deltaX = Math.cos(angle) * maxDistance;
                mobileJoystick.deltaY = Math.sin(angle) * maxDistance;
            } else {
                mobileJoystick.deltaX = deltaX;
                mobileJoystick.deltaY = deltaY;
            }
            
            // Atualizar posição visual do stick
            joystickStick.style.transform = `translate(calc(-50% + ${mobileJoystick.deltaX}px), calc(-50% + ${mobileJoystick.deltaY}px))`;
            
            // Mapear para teclas WASD (normalizado)
            const threshold = 10;
            keys['KeyW'] = mobileJoystick.deltaY < -threshold;
            keys['KeyS'] = mobileJoystick.deltaY > threshold;
            keys['KeyA'] = mobileJoystick.deltaX < -threshold;
            keys['KeyD'] = mobileJoystick.deltaX > threshold;
        }

        // Função para atualizar o tema do mundo (Alien)
        function updateWorldTheme() {
            const alienThemes = [
                { name: 'Corredores Escuros', fog: 0x000000, ambient: 0x000a0a, density: 0.02 },
                { name: 'Vazamento de Ácido', fog: 0x001100, ambient: 0x001a00, density: 0.015 },
                { name: 'Emergência', fog: 0x1a0000, ambient: 0x2a0000, density: 0.018 },
                { name: 'Infestação', fog: 0x0a1a0a, ambient: 0x0a2a0a, density: 0.025 }
            ];

            const theme = alienThemes[worldTheme % alienThemes.length];
            scene.fog = new THREE.FogExp2(theme.fog, theme.density);

            scene.children.forEach(child => {
                if (child instanceof THREE.AmbientLight) {
                    child.color.setHex(theme.ambient);
                    child.intensity = 0.05 + Math.random() * 0.05; // Muito escuro
                }
            });
        }

        // Função para criar tripulante da espaçonave
        function createCrewMember(isInteractive = false) {
            const group = new THREE.Object3D();
            const colors = [0x0066cc, 0x00cc66, 0xcc6600, 0x6600cc, 0xcc0066];
            const color = colors[Math.floor(Math.random() * colors.length)];
            const bodyMat = new THREE.MeshStandardMaterial({ 
                color: color, 
                emissive: color, 
                emissiveIntensity: 0.2 
            });

            const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1, 0.3), bodyMat);
            body.position.y = 0.5;
            group.add(body);

            const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), new THREE.MeshStandardMaterial({ color: 0xffcc99 }));
            head.position.y = 1.2;
            group.add(head);

            // Capacete espacial
            const helmet = new THREE.Mesh(
                new THREE.SphereGeometry(0.25, 16, 16),
                new THREE.MeshStandardMaterial({ 
                    color: 0xcccccc, 
                    transparent: true, 
                    opacity: 0.7,
                    emissive: 0x00d4ff,
                    emissiveIntensity: 0.1
                })
            );
            helmet.position.y = 1.2;
            group.add(helmet);

            if (isInteractive) {
                const label = createLabel('Portal está a ' + (Math.random() > 0.5 ? 'norte' : 'sul'), '#ffffff', 6);
                label.position.y = 2;
                label.visible = false;
                group.add(label);
            }

            return group;
        }

        // Função para criar estrutura principal da espaçonave infectada
        function createAlienSpaceshipStructure(theme) {
            // Paredes externas corroídas e infectadas
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: theme.wall,
                emissive: theme.bioGlow,
                emissiveIntensity: 0.08,
                roughness: 0.8
            });

            // Paredes norte e sul com crescimento orgânico
            for (let i = 0; i < 2; i++) {
                const wall = new THREE.Mesh(
                    new THREE.BoxGeometry(100, 20, 2),
                    wallMaterial
                );
                wall.position.set(0, 10, i === 0 ? -50 : 50);
                buildings.push(wall);
                scene.add(wall);

                // Crescimento orgânico nas paredes
                for (let j = 0; j < 5; j++) {
                    const growth = new THREE.Mesh(
                        new THREE.SphereGeometry(1 + Math.random() * 2, 8, 8),
                        new THREE.MeshStandardMaterial({ 
                            color: theme.organic,
                            emissive: theme.bioGlow,
                            emissiveIntensity: 0.3
                        })
                    );
                    growth.position.set(
                        Math.random() * 80 - 40,
                        5 + Math.random() * 10,
                        i === 0 ? -50.5 : 50.5
                    );
                    scene.add(growth);
                }
            }

            // Paredes leste e oeste
            for (let i = 0; i < 2; i++) {
                const wall = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 20, 100),
                    wallMaterial
                );
                wall.position.set(i === 0 ? -50 : 50, 10, 0);
                buildings.push(wall);
                scene.add(wall);

                // Crescimento orgânico
                for (let j = 0; j < 5; j++) {
                    const growth = new THREE.Mesh(
                        new THREE.SphereGeometry(1 + Math.random() * 2, 8, 8),
                        new THREE.MeshStandardMaterial({ 
                            color: theme.organic,
                            emissive: theme.bioGlow,
                            emissiveIntensity: 0.3
                        })
                    );
                    growth.position.set(
                        i === 0 ? -50.5 : 50.5,
                        5 + Math.random() * 10,
                        Math.random() * 80 - 40
                    );
                    scene.add(growth);
                }
            }

            // Teto corroído com vazamentos
            const ceiling = new THREE.Mesh(
                new THREE.PlaneGeometry(100, 100),
                new THREE.MeshStandardMaterial({ 
                    color: theme.metal,
                    emissive: theme.bioGlow,
                    emissiveIntensity: 0.05,
                    roughness: 0.9
                })
            );
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = 20;
            scene.add(ceiling);

            // Segundo andar com crescimento orgânico
            const secondFloor = new THREE.Mesh(
                new THREE.PlaneGeometry(80, 80),
                new THREE.MeshStandardMaterial({ 
                    color: theme.floor,
                    emissive: theme.bioGlow,
                    emissiveIntensity: 0.08
                })
            );
            secondFloor.rotation.x = -Math.PI / 2;
            secondFloor.position.y = 12;
            scene.add(secondFloor);

            // Adicionar crescimentos orgânicos no segundo andar
            for (let i = 0; i < 8; i++) {
                const organicGrowth = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.5 + Math.random() * 1, 1 + Math.random() * 1.5, 2 + Math.random() * 3, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: theme.organic,
                        emissive: theme.bioGlow,
                        emissiveIntensity: 0.4
                    })
                );
                organicGrowth.position.set(
                    Math.random() * 60 - 30,
                    13,
                    Math.random() * 60 - 30
                );
                scene.add(organicGrowth);
            }
        }

        // Função para criar cômodos infectados da espaçonave
        function createAlienSpaceshipRooms(theme) {
            const roomMaterial = new THREE.MeshStandardMaterial({ 
                color: theme.metal,
                emissive: theme.bioGlow,
                emissiveIntensity: 0.05,
                roughness: 0.8
            });

            // Ponte de comando infectada (centro, segundo andar)
            const bridge = new THREE.Mesh(
                new THREE.BoxGeometry(20, 8, 15),
                roomMaterial
            );
            bridge.position.set(0, 12, 0);
            buildings.push(bridge);
            scene.add(bridge);

            // Engenharia corroída (lado direito, primeiro andar)
            const engineering = new THREE.Mesh(
                new THREE.BoxGeometry(15, 8, 20),
                roomMaterial
            );
            engineering.position.set(25, 4, 0);
            buildings.push(engineering);
            scene.add(engineering);

            // Dormitórios infectados (lado esquerdo, primeiro andar)
            const dormitory = new THREE.Mesh(
                new THREE.BoxGeometry(18, 8, 12),
                roomMaterial
            );
            dormitory.position.set(-25, 4, 0);
            buildings.push(dormitory);
            scene.add(dormitory);

            // Laboratório biológico (fundo, segundo andar)
            const lab = new THREE.Mesh(
                new THREE.BoxGeometry(16, 8, 18),
                roomMaterial
            );
            lab.position.set(0, 12, 25);
            buildings.push(lab);
            scene.add(lab);

            // Armazém com ovos (frente, segundo andar)
            const storage = new THREE.Mesh(
                new THREE.BoxGeometry(14, 8, 16),
                roomMaterial
            );
            storage.position.set(0, 12, -25);
            buildings.push(storage);
            scene.add(storage);

            // Adicionar ovos de Alien no armazém
            for (let i = 0; i < 3; i++) {
                const egg = new THREE.Mesh(
                    new THREE.SphereGeometry(1, 8, 6, 0, Math.PI * 2, 0, Math.PI * 0.8),
                    new THREE.MeshStandardMaterial({ 
                        color: theme.organic,
                        emissive: theme.bioGlow,
                        emissiveIntensity: 0.2
                    })
                );
                egg.scale.set(1.2, 1.5, 1);
                egg.position.set(
                    Math.random() * 10 - 5,
                    12.5,
                    -25 + Math.random() * 12 - 6
                );
                scene.add(egg);
            }

            // Adicionar tecido orgânico nos cômodos
            for (let i = 0; i < 10; i++) {
                const tissue = new THREE.Mesh(
                    new THREE.SphereGeometry(0.5 + Math.random() * 1, 6, 6),
                    new THREE.MeshStandardMaterial({ 
                        color: theme.organic,
                        emissive: theme.bioGlow,
                        emissiveIntensity: 0.3
                    })
                );
                tissue.position.set(
                    Math.random() * 80 - 40,
                    2 + Math.random() * 10,
                    Math.random() * 80 - 40
                );
                scene.add(tissue);
            }
        }

        // Função para criar sistema de elevadores funcionais
        function createFunctionalElevatorSystem(theme) {
            // Criar 3 elevadores funcionais
            const elevatorPositions = [
                [0, 0],    // Centro
                [30, -20], // Lado direito
                [-30, 20]  // Lado esquerdo
            ];

            elevatorPositions.forEach((pos, i) => {
                const elevator = createFunctionalElevator(pos[0], pos[1], true);
                elevators.push(elevator);
                scene.add(elevator);
                
                // Adicionar plataforma aos walkways para colisão
                walkways.push(elevator.platform);
            });
        }

        // Função para criar sistema de portas labirínticas
        function createMazeDoors(theme) {
            // Criar várias portas pela nave
            const doorPositions = [
                [10, 0, 0], [-10, 0, 0],   // Portas norte-sul
                [0, 0, 10], [0, 0, -10],   // Portas leste-oeste
                [20, 0, 20], [-20, 0, -20], // Portas diagonais
                [25, 0, 0], [-25, 0, 0],   // Portas laterais
                [0, 12, 0], [15, 12, 15], [-15, 12, -15] // Portas segundo andar
            ];

            doorPositions.forEach((pos, i) => {
                const door = createDoor(pos[0], pos[1], pos[2]);
                doors.push(door);
                scene.add(door);
                
                // Adicionar porta aos buildings para colisão se fechada
                if (!door.isOpen) {
                    buildings.push(door.door);
                }
            });
        }

        // Função para criar sistema de escadas com crescimento orgânico
        function createAlienStairSystem(theme) {
            const stairMaterial = new THREE.MeshStandardMaterial({ 
                color: theme.metal,
                emissive: theme.bioGlow,
                emissiveIntensity: 0.08,
                roughness: 0.9
            });

            // Escadas principais corroídas (centro-lado)
            for (let i = 0; i < 2; i++) {
                const stairGroup = new THREE.Object3D();
                for (let j = 0; j < 6; j++) {
                    const step = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 0.5, 1.5),
                        stairMaterial
                    );
                    step.position.set(i === 0 ? -15 : 15, j * 0.5, -10 + j * 0.3);
                    stairGroup.add(step);

                    // Adicionar crescimento orgânico nos degraus
                    if (Math.random() > 0.7) {
                        const growth = new THREE.Mesh(
                            new THREE.SphereGeometry(0.3, 6, 6),
                            new THREE.MeshStandardMaterial({ 
                                color: theme.organic,
                                emissive: theme.bioGlow,
                                emissiveIntensity: 0.4
                            })
                        );
                        growth.position.set(
                            i === 0 ? -15 : 15, 
                            j * 0.5 + 0.3, 
                            -10 + j * 0.3
                        );
                        stairGroup.add(growth);
                    }
                }
                stairGroup.position.y = 0;
                scene.add(stairGroup);
                
                // Adicionar cada degrau aos walkways para colisão
                stairGroup.children.forEach(child => {
                    if (child.geometry.type === 'BoxGeometry') {
                        walkways.push(child);
                    }
                });
            }

            // Escadas laterais infectadas (conectando aos elevadores)
            for (let i = 0; i < 2; i++) {
                const sideStairGroup = new THREE.Object3D();
                for (let j = 0; j < 5; j++) {
                    const step = new THREE.Mesh(
                        new THREE.BoxGeometry(1.5, 0.5, 2),
                        stairMaterial
                    );
                    step.position.set(20 + j * 0.3, j * 0.5, i === 0 ? 15 : -15);
                    sideStairGroup.add(step);
                }
                sideStairGroup.position.y = 0;
                scene.add(sideStairGroup);
                
                sideStairGroup.children.forEach(step => {
                    walkways.push(step);
                });
            }
        }

        // Função para criar corredores infectados
        function createAlienCorridors(theme) {
            const corridorMaterial = new THREE.MeshStandardMaterial({ 
                color: theme.wall,
                emissive: theme.bioGlow,
                emissiveIntensity: 0.03,
                roughness: 0.8
            });

            // Corredor horizontal principal infectado (segundo andar)
            const mainCorridor = new THREE.Mesh(
                new THREE.BoxGeometry(60, 8, 4),
                corridorMaterial
            );
            mainCorridor.position.set(0, 12, 0);
            buildings.push(mainCorridor);
            scene.add(mainCorridor);

            // Corredor vertical principal infectado (segundo andar)
            const verticalCorridor = new THREE.Mesh(
                new THREE.BoxGeometry(4, 8, 50),
                corridorMaterial
            );
            verticalCorridor.position.set(0, 12, 0);
            buildings.push(verticalCorridor);
            scene.add(verticalCorridor);

            // Corredores de conexão infectados (primeiro andar)
            const floor1Corridor1 = new THREE.Mesh(
                new THREE.BoxGeometry(20, 8, 4),
                corridorMaterial
            );
            floor1Corridor1.position.set(0, 4, 0);
            buildings.push(floor1Corridor1);
            scene.add(floor1Corridor1);

            const floor1Corridor2 = new THREE.Mesh(
                new THREE.BoxGeometry(4, 8, 30),
                corridorMaterial
            );
            floor1Corridor2.position.set(0, 4, 0);
            buildings.push(floor1Corridor2);
            scene.add(floor1Corridor2);

            // Adicionar vazamentos de ácido nos corredores
            for (let i = 0; i < 6; i++) {
                const acidPool = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.5 + Math.random() * 1, 1 + Math.random() * 1.5, 0.1, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: theme.acid,
                        emissive: theme.acid,
                        emissiveIntensity: 0.6,
                        transparent: true,
                        opacity: 0.8
                    })
                );
                acidPool.position.set(
                    Math.random() * 40 - 20,
                    0.05,
                    Math.random() * 40 - 20
                );
                scene.add(acidPool);
            }
        }

        // Função para criar decorações sombrias da espaçonave infectada
        function createAlienDecorations(theme) {
            // Painéis de controle corroídos
            for (let i = 0; i < 8; i++) {
                const panel = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 3, 0.2),
                    new THREE.MeshStandardMaterial({ 
                        color: theme.metal,
                        emissive: theme.bioGlow,
                        emissiveIntensity: 0.1,
                        roughness: 0.9
                    })
                );
                const positions = [
                    [0, 1.5, 15], [-15, 1.5, 0], [15, 1.5, 0], [0, 1.5, -15],
                    [0, 13.5, 15], [-15, 13.5, 0], [15, 13.5, 0], [0, 13.5, -15]
                ];
                panel.position.set(positions[i][0], positions[i][1], positions[i][2]);
                scene.add(panel);

                // Adicionar crescimento orgânico nos painéis
                if (Math.random() > 0.6) {
                    const growth = new THREE.Mesh(
                        new THREE.SphereGeometry(0.3 + Math.random() * 0.5, 6, 6),
                        new THREE.MeshStandardMaterial({ 
                            color: theme.organic,
                            emissive: theme.bioGlow,
                            emissiveIntensity: 0.5
                        })
                    );
                    growth.position.set(
                        positions[i][0],
                        positions[i][1] + 0.5,
                        positions[i][2]
                    );
                    scene.add(growth);
                }
            }

            // Luzes de emergência piscando (menos luzes, mais atmosfera)
            for (let i = 0; i < 8; i++) {
                const light = new THREE.Mesh(
                    new THREE.SphereGeometry(0.4, 16, 16),
                    new THREE.MeshStandardMaterial({ 
                        color: theme.emergency,
                        emissive: theme.emergency,
                        emissiveIntensity: 0.7
                    })
                );
                const angle = (i / 8) * Math.PI * 2;
                const radius = 35;
                light.position.set(
                    Math.cos(angle) * radius,
                    18,
                    Math.sin(angle) * radius
                );
                scene.add(light);
            }

            // Consoles de computador quebrados
            for (let i = 0; i < 6; i++) {
                const console = new THREE.Mesh(
                    new THREE.BoxGeometry(3, 1.5, 1.5),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x1a1a1a,
                        emissive: theme.bioGlow,
                        emissiveIntensity: 0.15,
                        roughness: 0.9
                    })
                );
                const positions = [
                    [20, 0.75, 10], [-20, 0.75, 10], [20, 0.75, -10],
                    [-20, 0.75, -10], [0, 12.75, 20], [0, 12.75, -20]
                ];
                console.position.set(positions[i][0], positions[i][1], positions[i][2]);
                scene.add(console);
            }

            // Adicionar mais elementos orgânicos espalhados
            for (let i = 0; i < 15; i++) {
                const organicElement = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3 + Math.random() * 0.7, 6, 6),
                    new THREE.MeshStandardMaterial({ 
                        color: theme.organic,
                        emissive: theme.bioGlow,
                        emissiveIntensity: 0.3 + Math.random() * 0.4
                    })
                );
                organicElement.position.set(
                    Math.random() * 80 - 40,
                    1 + Math.random() * 15,
                    Math.random() * 80 - 40
                );
                scene.add(organicElement);
            }

            // Adicionar mais vazamentos de ácido
            for (let i = 0; i < 10; i++) {
                const acidLeak = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2, 0.8, 0.05, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: theme.acid,
                        emissive: theme.acid,
                        emissiveIntensity: 0.8,
                        transparent: true,
                        opacity: 0.9
                    })
                );
                acidLeak.position.set(
                    Math.random() * 60 - 30,
                    0.025,
                    Math.random() * 60 - 30
                );
                scene.add(acidLeak);
            }
        }

        // Função para gerar o mundo da espaçonave
        function generateWorld() {
            buildings.forEach(b => scene.remove(b));
            enemies.forEach(e => scene.remove(e.mesh));
            vehicles.forEach(v => scene.remove(v.mesh));
            pickups.forEach(p => scene.remove(p.mesh));
            pedestrians.forEach(p => scene.remove(p.mesh));
            sidewalks.forEach(s => scene.remove(s));
            roads.forEach(r => scene.remove(r));
            walkways.forEach(w => scene.remove(w));
            ramps.forEach(r => scene.remove(r));
            if (train) scene.remove(train.mesh);
            if (safeZone) scene.remove(safeZone);
            if (portal) scene.remove(portal);

            buildings = [];
            enemies = [];
            vehicles = [];
            pickups = [];
            pedestrians = [];
            sidewalks = [];
            roads = [];
            walkways = [];
            ramps = [];
            train = null;

            worldTheme++;
            updateWorldTheme();

            // Tema Alien - escuro e orgânico
            const alienTheme = {
                floor: 0x0a0a0a,
                wall: 0x1a1a1a,
                metal: 0x2a2a2a,
                organic: 0x4a2a1a,
                blood: 0x8b0000,
                acid: 0x00ff00,
                emergency: 0xff0000,
                bioGlow: 0x004400
            };

            // Chão base da espaçonave infectada
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(200, 200),
                new THREE.MeshStandardMaterial({ 
                    color: alienTheme.floor,
                    emissive: alienTheme.bioGlow,
                    emissiveIntensity: 0.05
                })
            );
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);

            // Criar estrutura principal da espaçonave infectada
            createAlienSpaceshipStructure(alienTheme);

            // Criar cômodos infectados
            createAlienSpaceshipRooms(alienTheme);

            // Criar sistema de elevadores funcionais
            createFunctionalElevatorSystem(alienTheme);

            // Criar escadas com crescimento orgânico
            createAlienStairSystem(alienTheme);

            // Criar corredores infectados
            createAlienCorridors(alienTheme);

            // Criar sistema de portas labirínticas
            createMazeDoors(alienTheme);

            // Adicionar elementos orgânicos e biológicos
            createAlienDecorations(alienTheme);

            // Criar drones/robôs da espaçonave (substituindo carros)
            for (let i = 0; i < 8; i++) {
                const droneGroup = new THREE.Object3D();
                const drone = new THREE.Mesh(
                    new THREE.BoxGeometry(4, 2, 4),
                    new THREE.MeshStandardMaterial({ 
                        color: alienTheme.metal,
                        emissive: alienTheme.bioGlow,
                        emissiveIntensity: 0.3
                    })
                );
                drone.position.y = 1;
                droneGroup.add(drone);

                // Propulsores do drone
                const thrusterMat = new THREE.MeshStandardMaterial({ 
                    color: 0xff6600,
                    emissive: 0xff6600,
                    emissiveIntensity: 0.8
                });

                const thruster1 = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, 0.5, 8), thrusterMat);
                thruster1.position.set(-1.5, 0.5, -1.5);
                droneGroup.add(thruster1);

                const thruster2 = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, 0.5, 8), thrusterMat);
                thruster2.position.set(1.5, 0.5, -1.5);
                droneGroup.add(thruster2);

                const thruster3 = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, 0.5, 8), thrusterMat);
                thruster3.position.set(-1.5, 0.5, 1.5);
                droneGroup.add(thruster3);

                const thruster4 = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, 0.5, 8), thrusterMat);
                thruster4.position.set(1.5, 0.5, 1.5);
                droneGroup.add(thruster4);

                droneGroup.position.set(
                    Math.random() * 80 - 40, 
                    Math.random() * 10 + 5, // Voar em diferentes alturas
                    Math.random() * 80 - 40
                );
                vehicles.push({
                    mesh: droneGroup,
                    wheels: [thruster1, thruster2, thruster3, thruster4],
                    speed: (Math.random() * 0.15 + 0.1) * (Math.random() > 0.5 ? 1 : -1),
                    axis: 'x'
                });
                scene.add(droneGroup);
            }

            // Criar Xenomorphs (Alien)
            for (let i = 0; i < 2 + level; i++) {
                const xenomorph = createXenomorph();
                const a = Math.random() * Math.PI * 2;
                const dist = Math.random() * 40 + 20;
                xenomorph.position.set(Math.cos(a) * dist, 0, Math.sin(a) * dist);
                enemies.push({
                    mesh: xenomorph,
                    speed: 0.06 + level * 0.015,
                    health: 8,
                    biteAnimation: 0,
                    isDead: false
                });
                scene.add(xenomorph);
            }

            // Criar Facehuggers (menores, mais numerosos)
            for (let i = 0; i < 4 + level * 2; i++) {
                const facehugger = createFacehugger();
                const a = Math.random() * Math.PI * 2;
                const dist = Math.random() * 30 + 15;
                facehugger.position.set(Math.cos(a) * dist, 0.15, Math.sin(a) * dist);
                enemies.push({
                    mesh: facehugger,
                    speed: 0.08 + level * 0.01,
                    health: 3,
                    biteAnimation: 0,
                    isDead: false
                });
                scene.add(facehugger);
            }

            // Criar Boss (Alien Queen) - apenas um por nível
            if (level % 3 === 0) {
                const alienBoss = createAlienBoss();
                alienBoss.position.set(0, 0, 0); // Centro da nave
                boss = {
                    mesh: alienBoss,
                    speed: 0.12, // Mais rápido que Xenomorphs normais
                    health: 20,
                    biteAnimation: 0,
                    isDead: false,
                    isBoss: true
                };
                enemies.push(boss);
                scene.add(alienBoss);
            }

            // Criar tripulantes da espaçonave (substituindo pedestres)
            for (let i = 0; i < 12; i++) {
                const isInteractive = Math.random() > 0.7;
                const crewMember = createCrewMember(isInteractive);
                crewMember.position.set(
                    Math.random() * 60 - 30,
                    2, // Andar principal
                    Math.random() * 60 - 30
                );
                const walkDir = Math.random() * Math.PI * 2;
                pedestrians.push({
                    mesh: crewMember,
                    direction: walkDir,
                    speed: 0.03 + Math.random() * 0.02,
                    walkCycle: Math.random() * 10,
                    isInteractive
                });
                scene.add(crewMember);
            }

            // Criar itens da espaçonave
            for (let i = 0; i < 15; i++) {
                const type = Math.random();
                let pickup;
                let label;
                if (type > 0.85) {
                    // Granadas
                    pickup = new THREE.Mesh(
                        new THREE.SphereGeometry(0.4, 8, 8),
                        new THREE.MeshStandardMaterial({ 
                            color: 0xff6600, 
                            emissive: 0xff6600, 
                            emissiveIntensity: 0.9 
                        })
                    );
                    label = createLabel('GRANADAS', '#ff6600');
                    pickup.type = 'grenades';
                } else if (type > 0.75) {
                    // Minas
                    pickup = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.5, 0.5, 0.3, 8),
                        new THREE.MeshStandardMaterial({ 
                            color: 0xffff00, 
                            emissive: 0xffff00, 
                            emissiveIntensity: 0.9 
                        })
                    );
                    label = createLabel('MINAS', '#ffff00');
                    pickup.type = 'mines';
                } else if (type > 0.65) {
                    // Lança-chamas
                    pickup = new THREE.Mesh(
                        new THREE.BoxGeometry(1.5, 0.3, 0.8),
                        new THREE.MeshStandardMaterial({ 
                            color: 0xff0000, 
                            emissive: 0xff0000, 
                            emissiveIntensity: 0.9 
                        })
                    );
                    label = createLabel('LANÇA-CHAMAS', '#ff0000');
                    pickup.type = 'flamethrower';
                } else if (type > 0.55) {
                    // Bazuca de energia
                    pickup = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 0.4, 0.6),
                        new THREE.MeshStandardMaterial({ 
                            color: 0x00ffff, 
                            emissive: 0x00ffff, 
                            emissiveIntensity: 0.9 
                        })
                    );
                    label = createLabel('BAZUCA PLASMA', '#00ffff');
                    pickup.type = 'plasma_launcher';
                } else if (type > 0.45) {
                    // Kit médico
                    pickup = createRedCross();
                    label = createLabel('MED KIT', '#ff0000');
                    pickup.type = 'health';
                } else if (type > 0.25) {
                    // Ração espacial
                    pickup = new THREE.Mesh(
                        new THREE.BoxGeometry(0.8, 0.8, 0.8),
                        new THREE.MeshStandardMaterial({ 
                            color: 0xffa500, 
                            emissive: 0xffa500, 
                            emissiveIntensity: 0.9 
                        })
                    );
                    label = createLabel('RATIONS', '#ffa500');
                    pickup.type = 'food';
                } else {
                    // Bateria de energia
                    pickup = new THREE.Mesh(
                        new THREE.BoxGeometry(1, 1.5, 0.5),
                        new THREE.MeshStandardMaterial({ 
                            color: 0x00d4ff, 
                            emissive: 0x00d4ff, 
                            emissiveIntensity: 0.8 
                        })
                    );
                    label = createLabel('ENERGY CELL', '#00d4ff');
                    pickup.type = 'energy';
                }
                pickup.position.set(Math.random() * 60 - 30, 1, Math.random() * 60 - 30);
                label.position.y = 2.5;
                pickup.add(label);
                pickups.push({ mesh: pickup, type: pickup.type, rotation: 0 });
                scene.add(pickup);
            }

            // Portal de evacuação da espaçonave
            safeZone = new THREE.Mesh(
                new THREE.BoxGeometry(8, 8, 8),
                new THREE.MeshStandardMaterial({ 
                    color: 0x00ff00, 
                    emissive: 0x00ff00, 
                    emissiveIntensity: 0.5, 
                    transparent: true, 
                    opacity: 0.6 
                })
            );
            const sa = Math.random() * Math.PI * 2;
            const sd = Math.random() * 50 + 40;
            safeZone.position.set(Math.cos(sa) * sd, 4, Math.sin(sa) * sd);
            scene.add(safeZone);

            // Portal de evacuação espacial
            portal = new THREE.Object3D();
            const portalRings = 5;
            for (let i = 0; i < portalRings; i++) {
                const ring = new THREE.Mesh(
                    new THREE.TorusGeometry(3 - i * 0.4, 0.15, 16, 32),
                    new THREE.MeshStandardMaterial({
                        color: 0x00ffff,
                        emissive: 0x00ffff,
                        emissiveIntensity: 1,
                        transparent: true,
                        opacity: 0.7 - i * 0.1
                    })
                );
                ring.rotation.y = (i * Math.PI) / portalRings;
                portal.add(ring);
            }

            const core = new THREE.Mesh(
                new THREE.SphereGeometry(1.5, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0x00ffff,
                    emissive: 0x00ffff,
                    emissiveIntensity: 1.5,
                    transparent: true,
                    opacity: 0.5
                })
            );
            portal.add(core);

            const exitLabel = createLabel('ESCAPE POD', '#00ffff', 8);
            exitLabel.position.y = 5;
            portal.add(exitLabel);

            portal.position.copy(safeZone.position);
            portal.position.y = 4;
            scene.add(portal);
        }

        // Função para verificar colisão (sem mudanças)
        function checkCollision(x, z, y = player.position.y) {
            const r = 1.5;
            for (let b of buildings) {
                const box = new THREE.Box3().setFromObject(b);
                const pBox = new THREE.Box3(
                    new THREE.Vector3(x - r, y - 1, z - r),
                    new THREE.Vector3(x + r, y + 2, z + r)
                );
                if (box.intersectsBox(pBox)) return true;
            }
            for (let v of vehicles) {
                const box = new THREE.Box3().setFromObject(v.mesh);
                const pBox = new THREE.Box3(
                    new THREE.Vector3(x - r, y - 1, z - r),
                    new THREE.Vector3(x + r, y + 2, z + r)
                );
                if (box.intersectsBox(pBox)) return true;
            }
            for (let w of walkways) {
                const box = new THREE.Box3().setFromObject(w);
                const pBox = new THREE.Box3(
                    new THREE.Vector3(x - r, y - 1, z - r),
                    new THREE.Vector3(x + r, y + 2, z + r)
                );
                if (box.intersectsBox(pBox)) {
                    player.position.y = w.position.y + 1.5;
                    return false;
                }
            }
            for (let r of ramps) {
                const box = new THREE.Box3().setFromObject(r);
                const pBox = new THREE.Box3(
                    new THREE.Vector3(x - r, y - 1, z - r),
                    new THREE.Vector3(x + r, y + 2, z + r)
                );
                if (box.intersectsBox(pBox)) {
                    player.position.y = r.position.y + 1.5;
                    return false;
                }
            }
            return false;
        }

        // Função para ajustar câmera para evitar obstruções (sem mudanças)
        function adjustCameraForObstructions() {
            if (cameraMode !== 'third') return;

            const playerHead = new THREE.Vector3(player.position.x, player.position.y + 1, player.position.z);
            const cameraPos = camera.position.clone();

            raycaster.set(cameraPos, playerHead.clone().sub(cameraPos).normalize());
            const intersects = raycaster.intersectObjects(buildings, true);

            if (intersects.length > 0) {
                // Se houver obstrução, elevar a câmera
                cameraOffset = Math.min(cameraOffset + 0.5, 10); // Limite de elevação
                camera.position.y += 0.5;
            } else {
                cameraOffset = Math.max(cameraOffset - 0.3, 0); // Reduzir elevação gradualmente
                camera.position.y -= 0.3;
            }
        }

        // Função de atualização do jogo (sem mudanças)
        function update() {
            if (gameOver) return;

            const isRunning = keys['ShiftLeft'] || keys['ShiftRight'];
            const baseSpeed = isRunning ? 0.25 : 0.15;
            const speed = stamina > 0 ? baseSpeed : baseSpeed * 0.5;
            let moving = false;
            let moveX = 0, moveZ = 0;

            if (isInTrain) {
                player.position.copy(train.mesh.position);
                player.position.y = 2;
                cameraMode = 'third';
            } else {
                if (cameraMode === 'god') {
                    // Inverter W e S na visão top down
                    if (keys['KeyW']) moveZ = -1; // Invertido
                    if (keys['KeyS']) moveZ = 1;  // Invertido
                    if (keys['KeyA']) moveX = -1;
                    if (keys['KeyD']) moveX = 1;
                } else if (cameraMode === 'first') {
                    // Movimento profissional baseado na câmera FPS
                    const { forward, right } = getFPSMovementDirection();
                    
                    if (keys['KeyW']) {
                        moveX += forward.x;
                        moveZ += forward.z;
                    }
                    if (keys['KeyS']) {
                        moveX -= forward.x;
                        moveZ -= forward.z;
                    }
                    if (keys['KeyA']) {
                        moveX -= right.x;
                        moveZ -= right.z;
                    }
                    if (keys['KeyD']) {
                        moveX += right.x;
                        moveZ += right.z;
                    }
                } else {
                    if (keys['KeyW']) moveZ = 1;
                    if (keys['KeyS']) moveZ = -1;
                    if (keys['KeyA']) moveX = 1;
                    if (keys['KeyD']) moveX = -1;
                }
                if (moveX !== 0 || moveZ !== 0) moving = true;

                if (moving) {
                    const nx = player.position.x + moveX * speed;
                    const nz = player.position.z + moveZ * speed;
                    // DESABILITAR checkCollision temporariamente para testar
                    player.position.x = nx;
                    player.position.z = nz;

                    // Só rotacionar o personagem se não estiver em primeira pessoa
                    if (cameraMode !== 'first') {
                        const targetAngle = Math.atan2(moveX, moveZ);
                        player.rotation.y = targetAngle;
                    }

                    // Movimento sem consumo de stamina para não interferir no pulo
                } else {
                    stamina = Math.min(100, stamina + 0.3);
                }
            }

            // SISTEMA IGUAL ÀS PASSARELAS - FUNCIONA EM TODO LUGAR!
            
            // Aplicar gravidade
            velocity.y -= 0.02;
            player.position.y += velocity.y;
            
            // Detecção de chão igual às passarelas - usando checkCollision
            const playerBox = new THREE.Box3(
                new THREE.Vector3(player.position.x - 1.5, player.position.y - 1, player.position.z - 1.5),
                new THREE.Vector3(player.position.x + 1.5, player.position.y + 2, player.position.z + 1.5)
            );
            
            let onGround = false;
            
            // Verificar passarelas (funciona)
            for (let w of walkways) {
                const walkwayBox = new THREE.Box3().setFromObject(w);
                if (walkwayBox.intersectsBox(playerBox)) {
                    player.position.y = w.position.y + 1.5;
                    velocity.y = 0;
                    onGround = true;
                    break;
                }
            }
            
            // Verificar rampas
            if (!onGround) {
                for (let r of ramps) {
                    const rampBox = new THREE.Box3().setFromObject(r);
                    if (rampBox.intersectsBox(playerBox)) {
                        player.position.y = r.position.y + 1.5;
                        velocity.y = 0;
                        onGround = true;
                        break;
                    }
                }
            }
            
            // Verificar chão normal - ALTURA SIMPLES COMO NAS PASSARELAS
            if (!onGround && player.position.y <= 2.1) {
                player.position.y = 2;
                velocity.y = 0;
                onGround = true;
            }
            
            isOnGround = onGround;
            
            // Pulo ou sair do trem
            if (keys['Space']) {
                if (isInTrain) {
                    // Sair do trem ao pressionar SPACE
                    isInTrain = false;
                    player.position.x += 5; // Sair para o lado
                    player.position.y = 2;
                    velocity.y = 0.5; // Pequeno pulo ao sair
                } else {
                    // Pulo normal fora do trem
                    velocity.y = 0.5;
                }
            }

            // Animação de caminhada - DEPOIS do pulo
            if (moving && !isInTrain) {
                walkCycle += 0.15;
                const swing = Math.sin(walkCycle) * 0.4;
                leftArm.rotation.x = swing;
                rightArm.rotation.x = -swing;
                leftLeg.rotation.x = -swing * 0.8;
                rightLeg.rotation.x = swing * 0.8;
            } else {
                walkCycle = 0;
                leftArm.rotation.x = 0;
                rightArm.rotation.x = 0;
                leftLeg.rotation.x = 0;
                rightLeg.rotation.x = 0;
            }

            pickups.forEach((p, i) => {
                const d = player.position.distanceTo(p.mesh.position);
                if (d < 3) {
                    if (p.type === 'weapon') {
                        hasWeapon = true;
                        document.getElementById('weapon').textContent = 'Laser Gun';
                        score += 50;
                    } else if (p.type === 'health') {
                        health = Math.min(100, health + 30);
                    } else if (p.type === 'food') {
                        stamina = Math.min(100, stamina + 70); // Aumentada recuperação de comida para 70
                    } else if (p.type === 'energy') {
                        stamina = Math.min(100, stamina + 50); // Bateria de energia
                        health = Math.min(100, health + 10); // Pequena recuperação de vida
                        score += 25;
                    }
                    scene.remove(p.mesh);
                    pickups.splice(i, 1);
                }
            });

            if (safeZone && player.position.distanceTo(safeZone.position) < 8) {
                level++;
                score += 100;
                isInTrain = false;
                generateWorld();
                // Reposicionar jogador na espaçonave após gerar novo mundo
                player.position.set(0, 2, 0);
            }

            const lim = 100;
            player.position.x = Math.max(-lim, Math.min(lim, player.position.x));
            player.position.z = Math.max(-lim, Math.min(lim, player.position.z));

            enemies.forEach((e, i) => {
                if (e.isDead) {
                    e.mesh.rotation.x += 0.05;
                    e.mesh.position.y -= 0.02;
                    if (e.mesh.position.y < -5) {
                        scene.remove(e.mesh);
                        enemies.splice(i, 1);
                    }
                    return;
                }

                const dir = new THREE.Vector3().subVectors(player.position, e.mesh.position).normalize();
                const distToPlayer = player.position.distanceTo(e.mesh.position);
                const nx = e.mesh.position.x + dir.x * e.speed;
                const nz = e.mesh.position.z + dir.z * e.speed;

                let hit = false;
                const r = 2;
                for (let b of buildings) {
                    const box = new THREE.Box3().setFromObject(b);
                    const eBox = new THREE.Box3(
                        new THREE.Vector3(nx - r, e.mesh.position.y, nz - r),
                        new THREE.Vector3(nx + r, e.mesh.position.y + 2, nz + r)
                    );
                    if (box.intersectsBox(eBox)) {
                        hit = true;
                        break;
                    }
                }

                if (!hit) {
                    e.mesh.position.x = nx;
                    e.mesh.position.z = nz;
                }

                e.mesh.rotation.y = Math.atan2(player.position.x - e.mesh.position.x, player.position.z - e.mesh.position.z);

                if (distToPlayer < 3) {
                    e.biteAnimation += 0.3;
                    const head = e.mesh.children[1];
                    if (head) {
                        head.rotation.x = Math.sin(e.biteAnimation) * 0.5;
                    }

                    if (Math.sin(e.biteAnimation) > 0.9) {
                        health -= 0.5;
                        if (health <= 0) {
                            gameOver = true;
                            document.getElementById('gameOver').style.display = 'block';
                        }
                    }
                } else {
                    e.biteAnimation = 0;
                    const head = e.mesh.children[1];
                    if (head) {
                        head.rotation.x = 0;
                    }
                }

                projectiles.forEach((p, pi) => {
                    if (e.mesh.position.distanceTo(p.mesh.position) < 3.5) {
                        e.health--;
                        createExplosion(p.mesh.position);
                        scene.remove(p.mesh);
                        projectiles.splice(pi, 1);

                        e.mesh.children.forEach(child => {
                            if (child.material) {
                                child.material.emissiveIntensity = 2;
                                setTimeout(() => {
                                    if (child.material) child.material.emissiveIntensity = 0.5;
                                }, 100);
                            }
                        });

                        if (e.health <= 0) {
                            e.isDead = true;
                            score += 25;
                        }
                    }
                });
            });

            projectiles.forEach((p, i) => {
                p.mesh.position.add(p.velocity);
                let remove = false;
                for (let b of buildings) {
                    if (new THREE.Box3().setFromObject(b).intersectsBox(new THREE.Box3().setFromObject(p.mesh))) {
                        remove = true;
                        break;
                    }
                }
                if (remove || p.mesh.position.length() > 200) {
                    scene.remove(p.mesh);
                    projectiles.splice(i, 1);
                }
            });

            vehicles.forEach(v => {
                const oldX = v.mesh.position.x;
                v.mesh.position.x += v.speed;
                if (Math.abs(v.mesh.position.x) > 100) v.mesh.position.x = -v.mesh.position.x;
                v.wheels.forEach(w => w.rotation.x += v.speed * 0.5);

                const carBox = new THREE.Box3().setFromObject(v.mesh);
                const playerBox = new THREE.Box3(
                    new THREE.Vector3(player.position.x - 1, player.position.y - 1, player.position.z - 1),
                    new THREE.Vector3(player.position.x + 1, player.position.y + 2, player.position.z + 1)
                );

                if (carBox.intersectsBox(playerBox) && player.position.y < 2.5 && !isInTrain) {
                    health -= 1;
                    const pushDir = new THREE.Vector3().subVectors(player.position, v.mesh.position).normalize();
                    player.position.x += pushDir.x * 2;
                    player.position.z += pushDir.z * 2;

                    v.mesh.children[0].material.emissiveIntensity = 2;
                    setTimeout(() => {
                        if (v.mesh.children[0].material) {
                            v.mesh.children[0].material.emissiveIntensity = 0.5;
                        }
                    }, 100);

                    if (health <= 0) {
                        gameOver = true;
                        document.getElementById('gameOver').style.display = 'block';
                    }
                }
            });

            // Atualizar trem
            if (train) {
                train.mesh.position.x += train.speed;
                if (Math.abs(train.mesh.position.x) > 100) train.mesh.position.x = -train.mesh.position.x;
                train.wheels.forEach(w => w.rotation.x += train.speed * 0.5);

                const trainBox = new THREE.Box3().setFromObject(train.mesh);
                const playerBox = new THREE.Box3(
                    new THREE.Vector3(player.position.x - 1, player.position.y - 1, player.position.z - 1),
                    new THREE.Vector3(player.position.x + 1, player.position.y + 2, player.position.z + 1)
                );

                if (trainBox.intersectsBox(playerBox) && !isInTrain) {
                    isInTrain = true;
                    player.position.copy(train.mesh.position);
                    player.position.y = 2;
                }
            }

            pedestrians.forEach(p => {
                p.walkCycle += 0.1;
                p.mesh.position.x += Math.sin(p.direction) * p.speed;
                p.mesh.position.z += Math.cos(p.direction) * p.speed;
                if (Math.abs(p.mesh.position.x) > 100 || Math.abs(p.mesh.position.z) > 100) {
                    p.direction = Math.random() * Math.PI * 2;
                    const sidewalkIndex = Math.floor(Math.random() * 5);
                    p.mesh.position.x = Math.random() * 80 - 40;
                    p.mesh.position.z = (sidewalkIndex - 2) * 20 + (sidewalkIndex % 2 === 0 ? 7.5 : -7.5);
                }

                if (p.isInteractive && p.mesh.children[2]) {
                    const dist = player.position.distanceTo(p.mesh.position);
                    p.mesh.children[2].visible = dist < 5;
                    if (dist < 5) {
                        p.mesh.children[2].lookAt(camera.position);
                        p.mesh.children[2].position.y = 2 + Math.sin(Date.now() * 0.002) * 0.2;
                    }
                }
            });

            if (safeZone) safeZone.rotation.y += 0.01;

            if (portal) {
                portal.rotation.y += 0.02;
                portal.rotation.z = Math.sin(Date.now() * 0.001) * 0.1;
                portal.children.forEach((child, i) => {
                    if (i < portal.children.length - 1) {
                        child.rotation.x += 0.01 * (i + 1);
                    }
                });
            }

            pickups.forEach(p => {
                p.rotation += 0.02;
                p.mesh.rotation.y = p.rotation;
                p.mesh.position.y = 0.5 + Math.sin(p.rotation * 2) * 0.3;
            });

            document.getElementById('health').textContent = Math.max(0, Math.floor(health));
            document.getElementById('stamina').textContent = Math.max(0, Math.floor(stamina));
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;

            // Atualizar câmera com base no modo
            if (cameraMode === 'first') {
                // Posicionar câmera na altura dos olhos do personagem
                camera.position.copy(player.position);
                camera.position.y += 1.6; // Altura dos olhos humanos
                
                // Aplicar rotação profissional FPS
                camera.rotation.order = 'YXZ'; // Ordem correta para FPS
                camera.rotation.y = fpsCamera.yaw;
                camera.rotation.x = fpsCamera.pitch;
                camera.rotation.z = 0;
                player.visible = false;
                
                // Mostrar arma em primeira pessoa se tiver arma
                if (hasWeapon) {
                    if (!fpsWeaponModel) {
                        fpsWeaponModel = createFPSWeapon();
                        camera.add(fpsWeaponModel);
                    }
                    // Animação de recuo ao atirar
                    if (fpsWeaponModel) {
                        fpsWeaponModel.visible = true;
                    }
                } else if (fpsWeaponModel) {
                    fpsWeaponModel.visible = false;
                }
            } else if (cameraMode === 'god') {
                camera.position.set(player.position.x, player.position.y + 20, player.position.z);
                camera.rotation.set(-Math.PI / 2, 0, 0);
                player.visible = true;
                
                // Ocultar arma FPS em outros modos
                if (fpsWeaponModel) {
                    fpsWeaponModel.visible = false;
                }
            } else {
                const d = 15, h = 8;
                const sway = Math.sin(walkCycle * 0.5) * 0.3;
                camera.position.x = player.position.x + sway;
                camera.position.y = player.position.y + h + Math.sin(walkCycle) * 0.2 + cameraOffset; // Aplicar offset para obstruções
                camera.position.z = player.position.z - d;
                camera.lookAt(player.position.x, player.position.y + 1, player.position.z);
                player.visible = true;
                
                // Ocultar arma FPS em outros modos
                if (fpsWeaponModel) {
                    fpsWeaponModel.visible = false;
                }
            }

            // Ajustar câmera para obstruções
            if (cameraMode === 'third') {
                adjustCameraForObstructions();
            }

            renderer.autoClear = false;
            renderer.clear();
            renderer.render(scene, camera);
            renderer.autoClear = true;
        }

        // Função de animação principal (sem mudanças)
        function animate() {
            requestAnimationFrame(animate);
            if (gameStarted) {
                update();
            } else {
                renderer.render(scene, camera);
            }
        }

        // Iniciar o jogo
        document.getElementById('startBtn').addEventListener('click', () => {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('customizationScreen').style.display = 'flex';
            initCustomizationPreview();
        });

        document.getElementById('confirmBtn').addEventListener('click', () => {
            document.getElementById('customizationScreen').style.display = 'none';
            
            // Remover renderer de preview com verificação de segurança
            if (previewRenderer && previewRenderer.domElement && previewRenderer.domElement.parentNode) {
                previewRenderer.domElement.parentNode.removeChild(previewRenderer.domElement);
            }
            
            gameStarted = true;
            init();
            animate();
        });
    </script>
</body>
</html>
